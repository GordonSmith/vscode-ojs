// Generated by vscode-ojs: Observable Notebook Kit compiled definitions

function cell_1(md) {
    
    return (
    md`# Reactive Demo
    
    _Quick demo with gang data_
    
    ---`
    )
    
}

function cell_2(Plot, data, setStartEnd, d3) {
    
    return (
    Plot.plot({
      x: {label: null},
      y: {percent: true},
      marks: [
        Plot.barY(data, {x: "letter", y: "frequency", fillOpacity: 0.2}),
        Plot.tickY(data, {x: "letter", y: "frequency"}),
        Plot.ruleY([0]),
        (index, scales, channels, dimensions, context) => {
          const x1 = dimensions.marginLeft;
          const x2 = dimensions.width - dimensions.marginRight;
          const y1 = 0;
          const y2 = dimensions.height;
          const brushed = (event) => setStartEnd(event.selection?.map(scales.x.invert));
          const brush = d3.brushX().extent([[x1, y1], [x2, y2]]).on("brush end", brushed);
          return d3.create("svg:g").call(brush).node();
        }
      ]
    })
    )
    
}

function cell_3(Mutable) {
    
    const startEnd = Mutable(null);
    const setStartEnd = (se) => startEnd.value = se;
    return {startEnd,setStartEnd};
    
}

function cell_5(FileAttachment, display) {
    
    const data = FileAttachment("./data/alphabet.csv").csv({typed: true}).then(display);
    return {data};
    
}

function cell_6(phonesTimeLineData, display) {
    
    const calls = Object.keys(phonesTimeLineData.events).map((key) => {
      const row = phonesTimeLineData.events[key];
      const caller = phonesTimeLineData.entities[row.entityIds[0]];
      return {
        id: key,
        caller: phonesTimeLineData.entities[row.entityIds[0]],
        caller_type: caller.type,
        recipient: phonesTimeLineData.entities[row.entityIds[1]],
        start: new Date(row.time.start),
        end: new Date(row.time.end)
      };
    });
    display(calls);
    const callRange = {
      start: new Date(Math.min(...calls.map(c => c.start))),
      end: new Date(Math.max(...calls.map(c => c.end)))
    };
    display(callRange);
    return {calls,callRange};
    
}

async function cell_9(display) {
    
    const {test} = await import("./lib.js").then((module) => {
      if (!("test" in module)) throw new SyntaxError(`export 'test' not found`);
      return module;
    });
    
    const xxx = test();
    display(xxx);
    return {test,xxx};
    
}

function cell_10(md) {
    
    return (
    md`---
    ## Phones timeline`
    )
    
}

async function cell_11(FileAttachment, display) {
    
    const phonesTimeLineData = await FileAttachment("./data/phonesTimeLineData.json").json();
    display(phonesTimeLineData);
    return {phonesTimeLineData};
    
}

function cell_12(md, callRange) {
    
    return (
    md`## Zoomable Timeline of Calls (${callRange.start.toLocaleDateString()} - ${callRange.end.toLocaleDateString()})`
    )
    
}

function cell_13(chart) {
    return(
    chart.element
    )
}

async function cell_14(FileAttachment, display) {
    
    const timeBarData = await FileAttachment("./data/timeBarData.json").json();
    display(timeBarData);
    return {timeBarData};
    
}

function cell_15(calls, margin) {
    
    function renderCalls(rootNode, scaleX) {
          const callUpdate = rootNode.selectAll(".call").data(calls);
          const callEnter = callUpdate.enter().append("line")
          .attr("class", "call")
    
          .attr("stroke", "black")
          .attr("stroke-width", 2);
          const callExit = callUpdate.exit().remove();
    
          callEnter.merge(callUpdate)
            .attr("x1", (d) => scaleX(d.start))
            .attr("x2", (d) => scaleX(d.end))
            .attr("y1", margin.top+0)
            .attr("y2", margin.top+10)
            .text((d, i) => d.id);
    }
    return {renderCalls};
    
}

async function cell_16(FileAttachment, display) {
    
    const adjacencyList = await FileAttachment("./data/adjacencyList.json").json();
    display(adjacencyList);
    return {adjacencyList};
    
}

function cell_17(md) {
    
    return (
    md`---
    
    ## Entities`
    )
    
}

async function cell_18(FileAttachment, display) {
    
    const entityLabelToIdDict = await FileAttachment("./data/entityLabelToIdDict.json").json();
    display(entityLabelToIdDict);
    return {entityLabelToIdDict};
    
}

function cell_19(entityLabelToIdDict) {
    
    // Create a two-way dictionary from entityLabelToIdDict
    const idToEntityLabelDict = {};
    for (const [label, id] of Object.entries(entityLabelToIdDict)) {
      idToEntityLabelDict[id] = label;
    }
    return {idToEntityLabelDict};
    
}

function cell_20(md) {
    
    return (
    md`---
    ## Calls
    `
    )
    
}

async function cell_21(FileAttachment, display) {
    
    const groupToChartIdsDict = await FileAttachment("./data/groupToChartIdsDict.json").json();
    display(groupToChartIdsDict);
    const phonesChartData = await FileAttachment("./data/phonesChartData.json").json();
    display(phonesChartData);
    return {groupToChartIdsDict,phonesChartData};
    
}

function cell_22(md) {
    
    return (
    md`---
    ## Utils`
    )
    
}

function cell_23(Inputs, chart) {
    return(
    Inputs.button("Reset zoom", { reduce: chart.reset })
    )
}

function cell_24(Inputs) {
    return(
    Inputs.range([1, 20], { value: 10, step: 1, label: "Years" })
    )
}

function cell_25(Timeline, scaleX, margin) {
    return(
    Timeline(scaleX, margin, 240)
    )
}

function cell_26(d3, width, MS_PER_HOUR, renderCalls, zoomPlugin) {
    return(
    function Timeline(scaleX, margin, height = 240) {
      let axis = {};
      let nodes = {};
    
      let originalScaleX = scaleX.copy();
    
      const parts = ["yearly", "daily", "weekly", "grid", "yearlyGrid"];
    
      const findDensityConfig = (map, value) => {
        for (const [limit, config] of map) {
          if (value < limit) {
            return config;
          }
        }
    
        return [];
      };
    
      const ensureTimeFormat = (value = "") => {
        return typeof value !== "function" ? d3.utcFormat(value) : value;
      };
    
      axis["yearly"] = (parentNode, density) => {
        const densityMap = [
          [
            3,
            [
              d3.utcMonth,
              (d) => {
                const startOfTheYear =
                  d.getUTCMonth() === 0 && d.getUTCDate() === 1;
                const format = startOfTheYear ? "%Y – %B" : "%B";
    
                return d3.utcFormat(format)(d);
              },
            ],
          ],
          [Infinity, [d3.utcYear, "%Y"]],
        ];
    
        let [interval, format] = findDensityConfig(densityMap, density);
        format = ensureTimeFormat(format);
    
        const el = parentNode
          .attr("transform", `translate(0,${margin.top - 48})`)
          .call(
            d3
              .axisTop(scaleX)
              .ticks(interval)
              .tickFormat(format)
              .tickSizeOuter(0)
          );
    
        el.select(".domain").remove();
    
        el.selectAll("text")
          .attr("y", 0)
          .attr("x", 6)
          .style("text-anchor", "start");
    
        el.selectAll("line").attr("y1", -7).attr("y2", 6);
      };
    
      axis["daily"] = (parentNode, density) => {
        const densityMap = [
          [1, [d3.utcDay, "%-d"]],
          [3, [d3.utcDay, ""]],
          [8, [d3.utcMonth, "%B"]],
          [13, [d3.utcMonth, "%b"]],
          [22, [d3.utcMonth, (d) => d3.utcFormat("%B")(d).charAt(0)]],
          [33, [d3.utcMonth.every(3), "Q%q"]],
          [Infinity, [d3.utcMonth.every(3), ""]],
        ];
    
        let [interval, format] = findDensityConfig(densityMap, density);
        format = ensureTimeFormat(format);
    
        const el = parentNode
          .attr("transform", `translate(0,${margin.top - 28})`)
          .call(
            d3
              .axisTop(scaleX)
              .ticks(interval)
              .tickFormat(format)
              .tickSizeOuter(0)
          );
    
        el.select(".domain").remove();
    
        el.selectAll("text")
          .attr("y", 0)
          .attr("x", 6)
          .style("text-anchor", "start");
    
        el.selectAll("line").attr("y1", -7).attr("y2", 0);
      };
    
      axis["weekly"] = (parentNode, density) => {
        const densityMap = [
          [10, [d3.utcMonday, (d) => +d3.utcFormat("%-V")(d)]],  // monday as first of week and zero based
          [33, [d3.utcMonday, ""]],
          [Infinity, [d3.utcMonday.every(4), ""]],
        ];
    
        let [interval, format] = findDensityConfig(densityMap, density);
        format = ensureTimeFormat(format);
    
        const el = parentNode
          .attr("transform", `translate(0,${margin.top - 8})`)
          .call(
            d3
              .axisTop(scaleX)
              .ticks(interval)
              .tickFormat(format)
              .tickSizeOuter(0)
          );
    
        el.select(".domain").remove();
        el.selectAll("line").style(
          "visibility",
          density > densityMap[0][0] ? "visible" : "hidden"
        );
    
        el.selectAll("text")
          .attr("y", 0)
          .attr("x", 6)
          .style("text-anchor", "start");
    
        el.selectAll("line").attr("y1", -7).attr("y2", 0);
      };
    
      axis["grid"] = (parentNode, density) => {
        const densityMap = [
          [1, [d3.utcDay]],
          [8, [d3.utcMonday]],
          [22, [d3.utcMonth]],
          [Infinity, [d3.utcMonth.every(3)]],
        ];
    
        const [interval] = findDensityConfig(densityMap, density);
    
        const el = parentNode
          .attr("transform", `translate(0,${margin.top})`)
          .call(d3.axisTop(scaleX).ticks(interval).tickSizeOuter(0));
    
        el.select(".domain").remove();
        el.selectAll("text").remove();
    
        el.selectAll("line")
          .attr("y1", 0)
          .attr("y2", height - margin.top - margin.bottom);
      };
    
      axis["yearlyGrid"] = (parentNode, density) => {
        const densityMap = [
          [3, [d3.utcMonth, "%B"]],
          [Infinity, [d3.utcYear, "%Y"]],
        ];
    
        let [interval, format] = findDensityConfig(densityMap, density);
        format = ensureTimeFormat(format);
    
        const el = parentNode
          .attr("transform", `translate(0,${margin.top})`)
          .call(
            d3
              .axisTop(scaleX)
              .ticks(interval)
              .tickFormat(format)
              .tickSizeOuter(0)
          );
    
        el.select(".domain").remove();
        el.selectAll("text").remove();
    
        el.selectAll("line")
          .attr("y1", 0)
          .attr("y2", height - margin.top - margin.bottom);
      };
    
      const setup = () => {
        const svg = d3.create("svg")
          .attr("width", width)
          .attr("height", height)
          .attr("viewBox", [0, 0, width, height])
          .classed("timeline", true)
          .attr("style", "max-width: 100%; height: auto; height: intrinsic;");
    
        const element = svg.node();
    
        const rootNode = svg.append("g").classed("timeline-axis", true);
    
        parts.forEach((part) => {
          nodes[part] = rootNode.append("g").classed(part, true);
        });
    
        const update = () => {
          const density = Math.abs(scaleX.invert(0) - scaleX.invert(1)) / MS_PER_HOUR; // in pixels per hour
    
          parts.forEach((part) => {
            nodes[part].call(axis[part], density);
          });
    
          renderCalls(rootNode, scaleX);
        };
    
        const { zoom, reset } = zoomPlugin(svg,
          ({ transform }) => {
            scaleX = transform.rescaleX(originalScaleX);
    
            update();
          }
        );
    
        update();
    
        return {
          element,
          update,
          reset,
        };
      };
    
      return setup();
    }
    )
}

function cell_27(d3, zoomScaleExtent, margin, width) {
    
    function zoomPlugin(svg, zoomed) {
      const zoom = d3.zoom()
        .scaleExtent(zoomScaleExtent)
        .extent([[margin.left, 0], [width - margin.right, 0]])
        .translateExtent([
          [margin.left, 0],
          [width - margin.right, 0]
        ])
        .filter(filter)
        .on("zoom", zoomed);
    
      svg.call(zoom);
    
      function reset() {
        svg.transition()
          .duration(750)
          .call(zoom.transform, d3.zoomIdentity);
      }
    
      // prevent scrolling then apply the default filter
      function filter(event) {
        event.preventDefault();
        return (!event.ctrlKey || event.type === 'wheel') && !event.button;
      }
    
      return {
        zoom,
        reset
      };
    }
    return {zoomPlugin};
    
}

function cell_28(callRange, d3, margin, width) {
    
    function getDate(date) {
      return new Date(date.toISOString().split('T')[0]);
    }
    
    const now = callRange.start;
    const until = callRange.end;
    
    const nowDate = new Date(callRange.start.getUTCFullYear(), 0, 1);
    const untilDate = new Date(callRange.end.getUTCFullYear(), 11, 31);
    
    const scaleX = d3.scaleUtc().domain([nowDate, untilDate]).range([margin.left, width - margin.right]);
    return {getDate,now,until,nowDate,untilDate,scaleX};
    
}

function cell_29(scaleX) {
    return(
    scaleX.domain()
    )
}

function cell_30(MS_PER_DAY) {
    
    function getDays(a, b) { return Math.abs(a - b) / MS_PER_DAY; }
    return {getDays};
    
}

function cell_31(getDays, scaleX) {
    return(
    getDays(...scaleX.domain())
    )
}

function cell_32(days) {
    return(
    [1, Math.round(days)]
    )
}

function cell_33() {
    return(
    { top: 80, right: 20, bottom: 20, left: 20 }
    )
}

function cell_34(MS_PER_HOUR) {
    return(
    24 * MS_PER_HOUR
    )
}

function cell_35() {
    return(
    60 * 60 * 1000
    )
}

function cell_36(MS_PER_DAY) {
    return(
    365.24 * MS_PER_DAY
    )
}

function cell_37(html) {
    return(
    html`
    <style type="text/css">
      .timeline {
        --background-color: #334155;
        --daily-gridline-color: #cbd5e1;
        --yearly-gridline-color: #e2e8f0;
        --yearly-tick-color: #e2e8f0;
        --yearly-label-color: #f8fafc;
        --daily-tick-color: #e2e8f0;
        --daily-label-color: #f8fafc;
        --weekly-tick-color: #e2e8f0;
        --weekly-label-color: #f8fafc;
    
        background-color: var(--background-color);
        border-radius: 0.25rem;
      }
    
      .calls-layer line.call-line {
        stroke: #38bdf8;
        stroke-width: 2;
        stroke-linecap: round;
        opacity: 0.9;
      }
      .calls-layer circle {
        fill: #f472b6;
        stroke: #0f172a;
        stroke-width: 1;
      }
      .calls-layer g.call:hover line.call-line {
        stroke: #fbbf24;
      }
      .calls-layer g.call:hover circle {
        fill: #fbbf24;
      }
    
      .timeline-axis line {
        shape-rendering: geometricPrecision;
        stroke-width: 0.5;
      }
    
      .timeline-axis .yearly line {
        stroke: var(--yearly-tick-color);
      }
    
      .timeline-axis .yearly text {
        color: var(--yearly-label-color);
      }
    
      .timeline-axis .daily line {
        stroke: var(--daily-tick-color);
      }
    
      .timeline-axis .daily text {
        color: var(--daily-label-color);
      }
    
      .timeline-axis .weekly line {
        stroke: var(--weekly-tick-color);
      }
    
      .timeline-axis .weekly text {
        color: var(--weekly-label-color);
      }
    
      .timeline-axis .grid line {
        stroke: var(--daily-gridline-color);
      }
    
      .timeline-axis .yearlyGrid line {
        stroke: var(--yearly-gridline-color);
      }
    </style>
    `
    )
}

const compiled = [
{
    "id": 1,
    "value": "# Reactive Demo\n\n_Quick demo with gang data_\n\n---",
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_1,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 2,
    "value": "Plot.plot({\n  x: {label: null},\n  y: {percent: true},\n  marks: [\n    Plot.barY(data, {x: \"letter\", y: \"frequency\", fillOpacity: 0.2}),\n    Plot.tickY(data, {x: \"letter\", y: \"frequency\"}),\n    Plot.ruleY([0]),\n    (index, scales, channels, dimensions, context) => {\n      const x1 = dimensions.marginLeft;\n      const x2 = dimensions.width - dimensions.marginRight;\n      const y1 = 0;\n      const y2 = dimensions.height;\n      const brushed = (event) => setStartEnd(event.selection?.map(scales.x.invert));\n      const brush = d3.brushX().extent([[x1, y1], [x2, y2]]).on(\"brush end\", brushed);\n      return d3.create(\"svg:g\").call(brush).node();\n    }\n  ]\n})\n",
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_2,
    "inputs": [
        "Plot",
        "data",
        "setStartEnd",
        "d3"
    ],
    "outputs": [],
    "autodisplay": true
},
{
    "id": 3,
    "value": "const startEnd = Mutable(null);\nconst setStartEnd = (se) => startEnd.value = se;",
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_3,
    "inputs": [
        "Mutable"
    ],
    "outputs": [
        "startEnd",
        "setStartEnd"
    ],
    "autodisplay": false
},
{
    "id": 5,
    "value": "const data = FileAttachment(\"./data/alphabet.csv\").csv({typed: true}).then(display);",
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_5,
    "inputs": [
        "FileAttachment",
        "display"
    ],
    "outputs": [
        "data"
    ],
    "autodisplay": false
},
{
    "id": 6,
    "value": "const calls = Object.keys(phonesTimeLineData.events).map((key) => {\n  const row = phonesTimeLineData.events[key];\n  const caller = phonesTimeLineData.entities[row.entityIds[0]];\n  return {\n    id: key,\n    caller: phonesTimeLineData.entities[row.entityIds[0]],\n    caller_type: caller.type,\n    recipient: phonesTimeLineData.entities[row.entityIds[1]],\n    start: new Date(row.time.start),\n    end: new Date(row.time.end)\n  };\n});\ndisplay(calls);\nconst callRange = {\n  start: new Date(Math.min(...calls.map(c => c.start))),\n  end: new Date(Math.max(...calls.map(c => c.end)))\n};\ndisplay(callRange);",
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_6,
    "inputs": [
        "phonesTimeLineData",
        "display"
    ],
    "outputs": [
        "calls",
        "callRange"
    ],
    "autodisplay": false
},
{
    "id": 9,
    "value": "import { test } from \"./lib.js\";\n\nconst xxx = test();\ndisplay(xxx);",
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_9,
    "inputs": [
        "display"
    ],
    "outputs": [
        "test",
        "xxx"
    ],
    "autodisplay": false
},
{
    "id": 10,
    "value": "---\n## Phones timeline",
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_10,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 11,
    "value": "const phonesTimeLineData = await FileAttachment(\"./data/phonesTimeLineData.json\").json();\ndisplay(phonesTimeLineData);",
    "mode": "js",
    "pinned": true,
    "hidden": false,
    "body": cell_11,
    "inputs": [
        "FileAttachment",
        "display"
    ],
    "outputs": [
        "phonesTimeLineData"
    ],
    "autodisplay": false
},
{
    "id": 12,
    "value": "md`## Zoomable Timeline of Calls (${callRange.start.toLocaleDateString()} - ${callRange.end.toLocaleDateString()})`",
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_12,
    "inputs": [
        "md",
        "callRange"
    ],
    "outputs": [],
    "autodisplay": true
},
{
    "id": 13,
    "value": "chart.element",
    "mode": "ojs",
    "pinned": false,
    "hidden": false,
    "body": cell_13,
    "inputs": [
        "chart"
    ],
    "autodisplay": true,
    "automutable": false,
    "autoview": false
},
{
    "id": 14,
    "value": "const timeBarData = await FileAttachment(\"./data/timeBarData.json\").json();\ndisplay(timeBarData);",
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_14,
    "inputs": [
        "FileAttachment",
        "display"
    ],
    "outputs": [
        "timeBarData"
    ],
    "autodisplay": false
},
{
    "id": 15,
    "value": "function renderCalls(rootNode, scaleX) {\n      const callUpdate = rootNode.selectAll(\".call\").data(calls);\n      const callEnter = callUpdate.enter().append(\"line\")\n      .attr(\"class\", \"call\")\n\n      .attr(\"stroke\", \"black\")\n      .attr(\"stroke-width\", 2);\n      const callExit = callUpdate.exit().remove();\n\n      callEnter.merge(callUpdate)\n        .attr(\"x1\", (d) => scaleX(d.start))\n        .attr(\"x2\", (d) => scaleX(d.end))\n        .attr(\"y1\", margin.top+0)\n        .attr(\"y2\", margin.top+10)\n        .text((d, i) => d.id);\n}",
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_15,
    "inputs": [
        "calls",
        "margin"
    ],
    "outputs": [
        "renderCalls"
    ],
    "autodisplay": false
},
{
    "id": 16,
    "value": "const adjacencyList = await FileAttachment(\"./data/adjacencyList.json\").json();\ndisplay(adjacencyList);",
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_16,
    "inputs": [
        "FileAttachment",
        "display"
    ],
    "outputs": [
        "adjacencyList"
    ],
    "autodisplay": false
},
{
    "id": 17,
    "value": "---\n\n## Entities",
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_17,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 18,
    "value": "const entityLabelToIdDict = await FileAttachment(\"./data/entityLabelToIdDict.json\").json();\ndisplay(entityLabelToIdDict);",
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_18,
    "inputs": [
        "FileAttachment",
        "display"
    ],
    "outputs": [
        "entityLabelToIdDict"
    ],
    "autodisplay": false
},
{
    "id": 19,
    "value": "// Create a two-way dictionary from entityLabelToIdDict\nconst idToEntityLabelDict = {};\nfor (const [label, id] of Object.entries(entityLabelToIdDict)) {\n  idToEntityLabelDict[id] = label;\n}\n",
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_19,
    "inputs": [
        "entityLabelToIdDict"
    ],
    "outputs": [
        "idToEntityLabelDict"
    ],
    "autodisplay": false
},
{
    "id": 20,
    "value": "---\n## Calls\n",
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_20,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 21,
    "value": "const groupToChartIdsDict = await FileAttachment(\"./data/groupToChartIdsDict.json\").json();\ndisplay(groupToChartIdsDict);\nconst phonesChartData = await FileAttachment(\"./data/phonesChartData.json\").json();\ndisplay(phonesChartData);",
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_21,
    "inputs": [
        "FileAttachment",
        "display"
    ],
    "outputs": [
        "groupToChartIdsDict",
        "phonesChartData"
    ],
    "autodisplay": false
},
{
    "id": 22,
    "value": "---\n## Utils",
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_22,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 23,
    "value": "Inputs.button(\"Reset zoom\", { reduce: chart.reset })",
    "mode": "ojs",
    "pinned": false,
    "hidden": false,
    "body": cell_23,
    "inputs": [
        "Inputs",
        "chart"
    ],
    "autodisplay": true,
    "automutable": false,
    "autoview": false
},
{
    "id": 24,
    "value": "viewof years = Inputs.range([1, 20], { value: 10, step: 1, label: \"Years\" })",
    "mode": "ojs",
    "pinned": false,
    "hidden": false,
    "output": "viewof$years",
    "body": cell_24,
    "inputs": [
        "Inputs"
    ],
    "autodisplay": true,
    "automutable": false,
    "autoview": true
},
{
    "id": 25,
    "value": "chart = Timeline(scaleX, margin, 240)",
    "mode": "ojs",
    "pinned": false,
    "hidden": true,
    "output": "chart",
    "body": cell_25,
    "inputs": [
        "Timeline",
        "scaleX",
        "margin"
    ],
    "autodisplay": false,
    "automutable": false,
    "autoview": false
},
{
    "id": 26,
    "value": "function Timeline(scaleX, margin, height = 240) {\n  let axis = {};\n  let nodes = {};\n\n  let originalScaleX = scaleX.copy();\n\n  const parts = [\"yearly\", \"daily\", \"weekly\", \"grid\", \"yearlyGrid\"];\n\n  const findDensityConfig = (map, value) => {\n    for (const [limit, config] of map) {\n      if (value < limit) {\n        return config;\n      }\n    }\n\n    return [];\n  };\n\n  const ensureTimeFormat = (value = \"\") => {\n    return typeof value !== \"function\" ? d3.utcFormat(value) : value;\n  };\n\n  axis[\"yearly\"] = (parentNode, density) => {\n    const densityMap = [\n      [\n        3,\n        [\n          d3.utcMonth,\n          (d) => {\n            const startOfTheYear =\n              d.getUTCMonth() === 0 && d.getUTCDate() === 1;\n            const format = startOfTheYear ? \"%Y – %B\" : \"%B\";\n\n            return d3.utcFormat(format)(d);\n          },\n        ],\n      ],\n      [Infinity, [d3.utcYear, \"%Y\"]],\n    ];\n\n    let [interval, format] = findDensityConfig(densityMap, density);\n    format = ensureTimeFormat(format);\n\n    const el = parentNode\n      .attr(\"transform\", `translate(0,${margin.top - 48})`)\n      .call(\n        d3\n          .axisTop(scaleX)\n          .ticks(interval)\n          .tickFormat(format)\n          .tickSizeOuter(0)\n      );\n\n    el.select(\".domain\").remove();\n\n    el.selectAll(\"text\")\n      .attr(\"y\", 0)\n      .attr(\"x\", 6)\n      .style(\"text-anchor\", \"start\");\n\n    el.selectAll(\"line\").attr(\"y1\", -7).attr(\"y2\", 6);\n  };\n\n  axis[\"daily\"] = (parentNode, density) => {\n    const densityMap = [\n      [1, [d3.utcDay, \"%-d\"]],\n      [3, [d3.utcDay, \"\"]],\n      [8, [d3.utcMonth, \"%B\"]],\n      [13, [d3.utcMonth, \"%b\"]],\n      [22, [d3.utcMonth, (d) => d3.utcFormat(\"%B\")(d).charAt(0)]],\n      [33, [d3.utcMonth.every(3), \"Q%q\"]],\n      [Infinity, [d3.utcMonth.every(3), \"\"]],\n    ];\n\n    let [interval, format] = findDensityConfig(densityMap, density);\n    format = ensureTimeFormat(format);\n\n    const el = parentNode\n      .attr(\"transform\", `translate(0,${margin.top - 28})`)\n      .call(\n        d3\n          .axisTop(scaleX)\n          .ticks(interval)\n          .tickFormat(format)\n          .tickSizeOuter(0)\n      );\n\n    el.select(\".domain\").remove();\n\n    el.selectAll(\"text\")\n      .attr(\"y\", 0)\n      .attr(\"x\", 6)\n      .style(\"text-anchor\", \"start\");\n\n    el.selectAll(\"line\").attr(\"y1\", -7).attr(\"y2\", 0);\n  };\n\n  axis[\"weekly\"] = (parentNode, density) => {\n    const densityMap = [\n      [10, [d3.utcMonday, (d) => +d3.utcFormat(\"%-V\")(d)]],  // monday as first of week and zero based\n      [33, [d3.utcMonday, \"\"]],\n      [Infinity, [d3.utcMonday.every(4), \"\"]],\n    ];\n\n    let [interval, format] = findDensityConfig(densityMap, density);\n    format = ensureTimeFormat(format);\n\n    const el = parentNode\n      .attr(\"transform\", `translate(0,${margin.top - 8})`)\n      .call(\n        d3\n          .axisTop(scaleX)\n          .ticks(interval)\n          .tickFormat(format)\n          .tickSizeOuter(0)\n      );\n\n    el.select(\".domain\").remove();\n    el.selectAll(\"line\").style(\n      \"visibility\",\n      density > densityMap[0][0] ? \"visible\" : \"hidden\"\n    );\n\n    el.selectAll(\"text\")\n      .attr(\"y\", 0)\n      .attr(\"x\", 6)\n      .style(\"text-anchor\", \"start\");\n\n    el.selectAll(\"line\").attr(\"y1\", -7).attr(\"y2\", 0);\n  };\n\n  axis[\"grid\"] = (parentNode, density) => {\n    const densityMap = [\n      [1, [d3.utcDay]],\n      [8, [d3.utcMonday]],\n      [22, [d3.utcMonth]],\n      [Infinity, [d3.utcMonth.every(3)]],\n    ];\n\n    const [interval] = findDensityConfig(densityMap, density);\n\n    const el = parentNode\n      .attr(\"transform\", `translate(0,${margin.top})`)\n      .call(d3.axisTop(scaleX).ticks(interval).tickSizeOuter(0));\n\n    el.select(\".domain\").remove();\n    el.selectAll(\"text\").remove();\n\n    el.selectAll(\"line\")\n      .attr(\"y1\", 0)\n      .attr(\"y2\", height - margin.top - margin.bottom);\n  };\n\n  axis[\"yearlyGrid\"] = (parentNode, density) => {\n    const densityMap = [\n      [3, [d3.utcMonth, \"%B\"]],\n      [Infinity, [d3.utcYear, \"%Y\"]],\n    ];\n\n    let [interval, format] = findDensityConfig(densityMap, density);\n    format = ensureTimeFormat(format);\n\n    const el = parentNode\n      .attr(\"transform\", `translate(0,${margin.top})`)\n      .call(\n        d3\n          .axisTop(scaleX)\n          .ticks(interval)\n          .tickFormat(format)\n          .tickSizeOuter(0)\n      );\n\n    el.select(\".domain\").remove();\n    el.selectAll(\"text\").remove();\n\n    el.selectAll(\"line\")\n      .attr(\"y1\", 0)\n      .attr(\"y2\", height - margin.top - margin.bottom);\n  };\n\n  const setup = () => {\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .classed(\"timeline\", true)\n      .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    const element = svg.node();\n\n    const rootNode = svg.append(\"g\").classed(\"timeline-axis\", true);\n\n    parts.forEach((part) => {\n      nodes[part] = rootNode.append(\"g\").classed(part, true);\n    });\n\n    const update = () => {\n      const density = Math.abs(scaleX.invert(0) - scaleX.invert(1)) / MS_PER_HOUR; // in pixels per hour\n\n      parts.forEach((part) => {\n        nodes[part].call(axis[part], density);\n      });\n\n      renderCalls(rootNode, scaleX);\n    };\n\n    const { zoom, reset } = zoomPlugin(svg,\n      ({ transform }) => {\n        scaleX = transform.rescaleX(originalScaleX);\n\n        update();\n      }\n    );\n\n    update();\n\n    return {\n      element,\n      update,\n      reset,\n    };\n  };\n\n  return setup();\n}",
    "mode": "ojs",
    "pinned": false,
    "hidden": false,
    "output": "Timeline",
    "body": cell_26,
    "inputs": [
        "d3",
        "width",
        "MS_PER_HOUR",
        "renderCalls",
        "zoomPlugin"
    ],
    "autodisplay": true,
    "automutable": false,
    "autoview": false
},
{
    "id": 27,
    "value": "function zoomPlugin(svg, zoomed) {\n  const zoom = d3.zoom()\n    .scaleExtent(zoomScaleExtent)\n    .extent([[margin.left, 0], [width - margin.right, 0]])\n    .translateExtent([\n      [margin.left, 0],\n      [width - margin.right, 0]\n    ])\n    .filter(filter)\n    .on(\"zoom\", zoomed);\n\n  svg.call(zoom);\n\n  function reset() {\n    svg.transition()\n      .duration(750)\n      .call(zoom.transform, d3.zoomIdentity);\n  }\n\n  // prevent scrolling then apply the default filter\n  function filter(event) {\n    event.preventDefault();\n    return (!event.ctrlKey || event.type === 'wheel') && !event.button;\n  }\n\n  return {\n    zoom,\n    reset\n  };\n}",
    "mode": "js",
    "pinned": false,
    "hidden": true,
    "body": cell_27,
    "inputs": [
        "d3",
        "zoomScaleExtent",
        "margin",
        "width"
    ],
    "outputs": [
        "zoomPlugin"
    ],
    "autodisplay": false
},
{
    "id": 28,
    "value": "function getDate(date) {\n  return new Date(date.toISOString().split('T')[0]);\n}\n\nconst now = callRange.start;\nconst until = callRange.end;\n\nconst nowDate = new Date(callRange.start.getUTCFullYear(), 0, 1);\nconst untilDate = new Date(callRange.end.getUTCFullYear(), 11, 31);\n\nconst scaleX = d3.scaleUtc().domain([nowDate, untilDate]).range([margin.left, width - margin.right]);",
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_28,
    "inputs": [
        "callRange",
        "d3",
        "margin",
        "width"
    ],
    "outputs": [
        "getDate",
        "now",
        "until",
        "nowDate",
        "untilDate",
        "scaleX"
    ],
    "autodisplay": false
},
{
    "id": 29,
    "value": "scaleX.domain()",
    "mode": "ojs",
    "pinned": true,
    "hidden": false,
    "body": cell_29,
    "inputs": [
        "scaleX"
    ],
    "autodisplay": true,
    "automutable": false,
    "autoview": false
},
{
    "id": 30,
    "value": "function getDays(a, b) { return Math.abs(a - b) / MS_PER_DAY; }",
    "mode": "js",
    "pinned": false,
    "hidden": true,
    "body": cell_30,
    "inputs": [
        "MS_PER_DAY"
    ],
    "outputs": [
        "getDays"
    ],
    "autodisplay": false
},
{
    "id": 31,
    "value": "days = getDays(...scaleX.domain())",
    "mode": "ojs",
    "pinned": false,
    "hidden": true,
    "output": "days",
    "body": cell_31,
    "inputs": [
        "getDays",
        "scaleX"
    ],
    "autodisplay": false,
    "automutable": false,
    "autoview": false
},
{
    "id": 32,
    "value": "zoomScaleExtent = [1, Math.round(days)]",
    "mode": "ojs",
    "pinned": false,
    "hidden": true,
    "output": "zoomScaleExtent",
    "body": cell_32,
    "inputs": [
        "days"
    ],
    "autodisplay": false,
    "automutable": false,
    "autoview": false
},
{
    "id": 33,
    "value": "margin = ({ top: 80, right: 20, bottom: 20, left: 20 });",
    "mode": "ojs",
    "pinned": false,
    "hidden": false,
    "output": "margin",
    "body": cell_33,
    "inputs": [],
    "autodisplay": true,
    "automutable": false,
    "autoview": false
},
{
    "id": 34,
    "value": "MS_PER_DAY = 24 * MS_PER_HOUR;",
    "mode": "ojs",
    "pinned": false,
    "hidden": false,
    "output": "MS_PER_DAY",
    "body": cell_34,
    "inputs": [
        "MS_PER_HOUR"
    ],
    "autodisplay": true,
    "automutable": false,
    "autoview": false
},
{
    "id": 35,
    "value": "MS_PER_HOUR = 60 * 60 * 1000;",
    "mode": "ojs",
    "pinned": false,
    "hidden": false,
    "output": "MS_PER_HOUR",
    "body": cell_35,
    "inputs": [],
    "autodisplay": true,
    "automutable": false,
    "autoview": false
},
{
    "id": 36,
    "value": "MS_PER_YEAR = 365.24 * MS_PER_DAY; // include leap year",
    "mode": "ojs",
    "pinned": false,
    "hidden": false,
    "output": "MS_PER_YEAR",
    "body": cell_36,
    "inputs": [
        "MS_PER_DAY"
    ],
    "autodisplay": true,
    "automutable": false,
    "autoview": false
},
{
    "id": 37,
    "value": "html`\n<style type=\"text/css\">\n  .timeline {\n    --background-color: #334155;\n    --daily-gridline-color: #cbd5e1;\n    --yearly-gridline-color: #e2e8f0;\n    --yearly-tick-color: #e2e8f0;\n    --yearly-label-color: #f8fafc;\n    --daily-tick-color: #e2e8f0;\n    --daily-label-color: #f8fafc;\n    --weekly-tick-color: #e2e8f0;\n    --weekly-label-color: #f8fafc;\n\n    background-color: var(--background-color);\n    border-radius: 0.25rem;\n  }\n\n  .calls-layer line.call-line {\n    stroke: #38bdf8;\n    stroke-width: 2;\n    stroke-linecap: round;\n    opacity: 0.9;\n  }\n  .calls-layer circle {\n    fill: #f472b6;\n    stroke: #0f172a;\n    stroke-width: 1;\n  }\n  .calls-layer g.call:hover line.call-line {\n    stroke: #fbbf24;\n  }\n  .calls-layer g.call:hover circle {\n    fill: #fbbf24;\n  }\n\n  .timeline-axis line {\n    shape-rendering: geometricPrecision;\n    stroke-width: 0.5;\n  }\n\n  .timeline-axis .yearly line {\n    stroke: var(--yearly-tick-color);\n  }\n\n  .timeline-axis .yearly text {\n    color: var(--yearly-label-color);\n  }\n\n  .timeline-axis .daily line {\n    stroke: var(--daily-tick-color);\n  }\n\n  .timeline-axis .daily text {\n    color: var(--daily-label-color);\n  }\n\n  .timeline-axis .weekly line {\n    stroke: var(--weekly-tick-color);\n  }\n\n  .timeline-axis .weekly text {\n    color: var(--weekly-label-color);\n  }\n\n  .timeline-axis .grid line {\n    stroke: var(--daily-gridline-color);\n  }\n\n  .timeline-axis .yearlyGrid line {\n    stroke: var(--yearly-gridline-color);\n  }\n</style>\n`",
    "mode": "ojs",
    "pinned": false,
    "hidden": false,
    "body": cell_37,
    "inputs": [
        "html"
    ],
    "autodisplay": true,
    "automutable": false,
    "autoview": false
}
];
export default compiled;
