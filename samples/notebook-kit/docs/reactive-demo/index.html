<!doctype html>
<notebook theme="slate">
  <title>reactive-demo</title>
  <script id="1" type="text/markdown">
    # Reactive Demo

    _Quick demo with gang data_

    ---
  </script>
  <script id="2" type="module">
    Plot.plot({
      x: {label: null},
      y: {percent: true},
      marks: [
        Plot.barY(data, {x: "letter", y: "frequency", fillOpacity: 0.2}),
        Plot.tickY(data, {x: "letter", y: "frequency"}),
        Plot.ruleY([0]),
        (index, scales, channels, dimensions, context) => {
          const x1 = dimensions.marginLeft;
          const x2 = dimensions.width - dimensions.marginRight;
          const y1 = 0;
          const y2 = dimensions.height;
          const brushed = (event) => setStartEnd(event.selection?.map(scales.x.invert));
          const brush = d3.brushX().extent([[x1, y1], [x2, y2]]).on("brush end", brushed);
          return d3.create("svg:g").call(brush).node();
        }
      ]
    })

  </script>
  <script id="3" type="module">
    const startEnd = Mutable(null);
    const setStartEnd = (se) => startEnd.value = se;
  </script>
  <script id="5" type="module">
    const data = FileAttachment("./data/alphabet.csv").csv({typed: true}).then(display);
  </script>
  <script id="6" type="module">
    const calls = Object.keys(phonesTimeLineData.events).map((key) => {
      const row = phonesTimeLineData.events[key];
      const caller = phonesTimeLineData.entities[row.entityIds[0]];
      return {
        id: key,
        caller: phonesTimeLineData.entities[row.entityIds[0]],
        caller_type: caller.type,
        recipient: phonesTimeLineData.entities[row.entityIds[1]],
        start: new Date(row.time.start),
        end: new Date(row.time.end)
      };
    });
    display(calls);
    const callRange = {
      start: new Date(Math.min(...calls.map(c => c.start))),
      end: new Date(Math.max(...calls.map(c => c.end)))
    };
    display(callRange);
  </script>
  <script id="9" type="module">
    import { test } from "./lib.js";

    const xxx = test();
    display(xxx);
  </script>
  <script id="10" type="text/markdown">
    ---
    ## Phones timeline
  </script>
  <script id="11" type="module" pinned="">
    const phonesTimeLineData = await FileAttachment("./data/phonesTimeLineData.json").json();
    display(phonesTimeLineData);
  </script>
  <script id="12" type="module">
    md`## Zoomable Timeline of Calls (${callRange.start.toLocaleDateString()} - ${callRange.end.toLocaleDateString()})`
  </script>
  <script id="13" type="application/vnd.observable.javascript">
    chart.element
  </script>
  <script id="14" type="module">
    const timeBarData = await FileAttachment("./data/timeBarData.json").json();
    display(timeBarData);
  </script>
  <script id="15" type="module">
    function renderCalls(rootNode, scaleX) {
          const callUpdate = rootNode.selectAll(".call").data(calls);
          const callEnter = callUpdate.enter().append("line")
          .attr("class", "call")

          .attr("stroke", "black")
          .attr("stroke-width", 2);
          const callExit = callUpdate.exit().remove();

          callEnter.merge(callUpdate)
            .attr("x1", (d) => scaleX(d.start))
            .attr("x2", (d) => scaleX(d.end))
            .attr("y1", margin.top+0)
            .attr("y2", margin.top+10)
            .text((d, i) => d.id);
    }
  </script>
  <script id="16" type="module">
    const adjacencyList = await FileAttachment("./data/adjacencyList.json").json();
    display(adjacencyList);
  </script>
  <script id="17" type="text/markdown">
    ---

    ## Entities
  </script>
  <script id="18" type="module">
    const entityLabelToIdDict = await FileAttachment("./data/entityLabelToIdDict.json").json();
    display(entityLabelToIdDict);
  </script>
  <script id="19" type="module">
    // Create a two-way dictionary from entityLabelToIdDict
    const idToEntityLabelDict = {};
    for (const [label, id] of Object.entries(entityLabelToIdDict)) {
      idToEntityLabelDict[id] = label;
    }

  </script>
  <script id="20" type="text/markdown">
    ---
    ## Calls

  </script>
  <script id="21" type="module">
    const groupToChartIdsDict = await FileAttachment("./data/groupToChartIdsDict.json").json();
    display(groupToChartIdsDict);
    const phonesChartData = await FileAttachment("./data/phonesChartData.json").json();
    display(phonesChartData);
  </script>
  <script id="22" type="text/markdown">
    ---
    ## Utils
  </script>
  <script id="23" type="application/vnd.observable.javascript">
    Inputs.button("Reset zoom", { reduce: chart.reset })
  </script>
  <script id="24" type="application/vnd.observable.javascript">
    viewof years = Inputs.range([1, 20], { value: 10, step: 1, label: "Years" })
  </script>
  <script id="25" type="application/vnd.observable.javascript" hidden="">
    chart = Timeline(scaleX, margin, 240)
  </script>
  <script id="26" type="application/vnd.observable.javascript">
    function Timeline(scaleX, margin, height = 240) {
      let axis = {};
      let nodes = {};

      let originalScaleX = scaleX.copy();

      const parts = ["yearly", "daily", "weekly", "grid", "yearlyGrid"];

      const findDensityConfig = (map, value) => {
        for (const [limit, config] of map) {
          if (value < limit) {
            return config;
          }
        }

        return [];
      };

      const ensureTimeFormat = (value = "") => {
        return typeof value !== "function" ? d3.utcFormat(value) : value;
      };

      axis["yearly"] = (parentNode, density) => {
        const densityMap = [
          [
            3,
            [
              d3.utcMonth,
              (d) => {
                const startOfTheYear =
                  d.getUTCMonth() === 0 && d.getUTCDate() === 1;
                const format = startOfTheYear ? "%Y â€“ %B" : "%B";

                return d3.utcFormat(format)(d);
              },
            ],
          ],
          [Infinity, [d3.utcYear, "%Y"]],
        ];

        let [interval, format] = findDensityConfig(densityMap, density);
        format = ensureTimeFormat(format);

        const el = parentNode
          .attr("transform", `translate(0,${margin.top - 48})`)
          .call(
            d3
              .axisTop(scaleX)
              .ticks(interval)
              .tickFormat(format)
              .tickSizeOuter(0)
          );

        el.select(".domain").remove();

        el.selectAll("text")
          .attr("y", 0)
          .attr("x", 6)
          .style("text-anchor", "start");

        el.selectAll("line").attr("y1", -7).attr("y2", 6);
      };

      axis["daily"] = (parentNode, density) => {
        const densityMap = [
          [1, [d3.utcDay, "%-d"]],
          [3, [d3.utcDay, ""]],
          [8, [d3.utcMonth, "%B"]],
          [13, [d3.utcMonth, "%b"]],
          [22, [d3.utcMonth, (d) => d3.utcFormat("%B")(d).charAt(0)]],
          [33, [d3.utcMonth.every(3), "Q%q"]],
          [Infinity, [d3.utcMonth.every(3), ""]],
        ];

        let [interval, format] = findDensityConfig(densityMap, density);
        format = ensureTimeFormat(format);

        const el = parentNode
          .attr("transform", `translate(0,${margin.top - 28})`)
          .call(
            d3
              .axisTop(scaleX)
              .ticks(interval)
              .tickFormat(format)
              .tickSizeOuter(0)
          );

        el.select(".domain").remove();

        el.selectAll("text")
          .attr("y", 0)
          .attr("x", 6)
          .style("text-anchor", "start");

        el.selectAll("line").attr("y1", -7).attr("y2", 0);
      };

      axis["weekly"] = (parentNode, density) => {
        const densityMap = [
          [10, [d3.utcMonday, (d) => +d3.utcFormat("%-V")(d)]],  // monday as first of week and zero based
          [33, [d3.utcMonday, ""]],
          [Infinity, [d3.utcMonday.every(4), ""]],
        ];

        let [interval, format] = findDensityConfig(densityMap, density);
        format = ensureTimeFormat(format);

        const el = parentNode
          .attr("transform", `translate(0,${margin.top - 8})`)
          .call(
            d3
              .axisTop(scaleX)
              .ticks(interval)
              .tickFormat(format)
              .tickSizeOuter(0)
          );

        el.select(".domain").remove();
        el.selectAll("line").style(
          "visibility",
          density > densityMap[0][0] ? "visible" : "hidden"
        );

        el.selectAll("text")
          .attr("y", 0)
          .attr("x", 6)
          .style("text-anchor", "start");

        el.selectAll("line").attr("y1", -7).attr("y2", 0);
      };

      axis["grid"] = (parentNode, density) => {
        const densityMap = [
          [1, [d3.utcDay]],
          [8, [d3.utcMonday]],
          [22, [d3.utcMonth]],
          [Infinity, [d3.utcMonth.every(3)]],
        ];

        const [interval] = findDensityConfig(densityMap, density);

        const el = parentNode
          .attr("transform", `translate(0,${margin.top})`)
          .call(d3.axisTop(scaleX).ticks(interval).tickSizeOuter(0));

        el.select(".domain").remove();
        el.selectAll("text").remove();

        el.selectAll("line")
          .attr("y1", 0)
          .attr("y2", height - margin.top - margin.bottom);
      };

      axis["yearlyGrid"] = (parentNode, density) => {
        const densityMap = [
          [3, [d3.utcMonth, "%B"]],
          [Infinity, [d3.utcYear, "%Y"]],
        ];

        let [interval, format] = findDensityConfig(densityMap, density);
        format = ensureTimeFormat(format);

        const el = parentNode
          .attr("transform", `translate(0,${margin.top})`)
          .call(
            d3
              .axisTop(scaleX)
              .ticks(interval)
              .tickFormat(format)
              .tickSizeOuter(0)
          );

        el.select(".domain").remove();
        el.selectAll("text").remove();

        el.selectAll("line")
          .attr("y1", 0)
          .attr("y2", height - margin.top - margin.bottom);
      };

      const setup = () => {
        const svg = d3.create("svg")
          .attr("width", width)
          .attr("height", height)
          .attr("viewBox", [0, 0, width, height])
          .classed("timeline", true)
          .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

        const element = svg.node();

        const rootNode = svg.append("g").classed("timeline-axis", true);

        parts.forEach((part) => {
          nodes[part] = rootNode.append("g").classed(part, true);
        });

        const update = () => {
          const density = Math.abs(scaleX.invert(0) - scaleX.invert(1)) / MS_PER_HOUR; // in pixels per hour

          parts.forEach((part) => {
            nodes[part].call(axis[part], density);
          });

          renderCalls(rootNode, scaleX);
        };

        const { zoom, reset } = zoomPlugin(svg,
          ({ transform }) => {
            scaleX = transform.rescaleX(originalScaleX);

            update();
          }
        );

        update();

        return {
          element,
          update,
          reset,
        };
      };

      return setup();
    }
  </script>
  <script id="27" type="module" hidden="">
    function zoomPlugin(svg, zoomed) {
      const zoom = d3.zoom()
        .scaleExtent(zoomScaleExtent)
        .extent([[margin.left, 0], [width - margin.right, 0]])
        .translateExtent([
          [margin.left, 0],
          [width - margin.right, 0]
        ])
        .filter(filter)
        .on("zoom", zoomed);

      svg.call(zoom);

      function reset() {
        svg.transition()
          .duration(750)
          .call(zoom.transform, d3.zoomIdentity);
      }

      // prevent scrolling then apply the default filter
      function filter(event) {
        event.preventDefault();
        return (!event.ctrlKey || event.type === 'wheel') && !event.button;
      }

      return {
        zoom,
        reset
      };
    }
  </script>
  <script id="28" type="module">
    function getDate(date) {
      return new Date(date.toISOString().split('T')[0]);
    }

    const now = callRange.start;
    const until = callRange.end;

    const nowDate = new Date(callRange.start.getUTCFullYear(), 0, 1);
    const untilDate = new Date(callRange.end.getUTCFullYear(), 11, 31);

    const scaleX = d3.scaleUtc().domain([nowDate, untilDate]).range([margin.left, width - margin.right]);
  </script>
  <script id="29" type="application/vnd.observable.javascript" pinned="">
    scaleX.domain()
  </script>
  <script id="30" type="module" hidden="">
    function getDays(a, b) { return Math.abs(a - b) / MS_PER_DAY; }
  </script>
  <script id="31" type="application/vnd.observable.javascript" hidden="">
    days = getDays(...scaleX.domain())
  </script>
  <script id="32" type="application/vnd.observable.javascript" hidden="">
    zoomScaleExtent = [1, Math.round(days)]
  </script>
  <script id="33" type="application/vnd.observable.javascript">
    margin = ({ top: 80, right: 20, bottom: 20, left: 20 });
  </script>
  <script id="34" type="application/vnd.observable.javascript">
    MS_PER_DAY = 24 * MS_PER_HOUR;
  </script>
  <script id="35" type="application/vnd.observable.javascript">
    MS_PER_HOUR = 60 * 60 * 1000;
  </script>
  <script id="36" type="application/vnd.observable.javascript">
    MS_PER_YEAR = 365.24 * MS_PER_DAY; // include leap year
  </script>
  <script id="37" type="application/vnd.observable.javascript">
    html`
    <style type="text/css">
      .timeline {
        --background-color: #334155;
        --daily-gridline-color: #cbd5e1;
        --yearly-gridline-color: #e2e8f0;
        --yearly-tick-color: #e2e8f0;
        --yearly-label-color: #f8fafc;
        --daily-tick-color: #e2e8f0;
        --daily-label-color: #f8fafc;
        --weekly-tick-color: #e2e8f0;
        --weekly-label-color: #f8fafc;

        background-color: var(--background-color);
        border-radius: 0.25rem;
      }

      .calls-layer line.call-line {
        stroke: #38bdf8;
        stroke-width: 2;
        stroke-linecap: round;
        opacity: 0.9;
      }
      .calls-layer circle {
        fill: #f472b6;
        stroke: #0f172a;
        stroke-width: 1;
      }
      .calls-layer g.call:hover line.call-line {
        stroke: #fbbf24;
      }
      .calls-layer g.call:hover circle {
        fill: #fbbf24;
      }

      .timeline-axis line {
        shape-rendering: geometricPrecision;
        stroke-width: 0.5;
      }

      .timeline-axis .yearly line {
        stroke: var(--yearly-tick-color);
      }

      .timeline-axis .yearly text {
        color: var(--yearly-label-color);
      }

      .timeline-axis .daily line {
        stroke: var(--daily-tick-color);
      }

      .timeline-axis .daily text {
        color: var(--daily-label-color);
      }

      .timeline-axis .weekly line {
        stroke: var(--weekly-tick-color);
      }

      .timeline-axis .weekly text {
        color: var(--weekly-label-color);
      }

      .timeline-axis .grid line {
        stroke: var(--daily-gridline-color);
      }

      .timeline-axis .yearlyGrid line {
        stroke: var(--yearly-gridline-color);
      }
    </style>
    `
  </script>
</notebook>
