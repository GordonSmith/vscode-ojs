// Generated by vscode-ojs: Observable Notebook Kit export
// Source: index.html
const notebook = {
  "cells": [
    {
      "id": 1,
      "value": "# Reactive Demo\n\n_Quick demo with gang data_\n\n---",
      "mode": "md",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 2,
      "value": "Plot.plot({\n  x: {label: null},\n  y: {percent: true},\n  marks: [\n    Plot.barY(data, {x: \"letter\", y: \"frequency\", fillOpacity: 0.2}),\n    Plot.tickY(data, {x: \"letter\", y: \"frequency\"}),\n    Plot.ruleY([0]),\n    (index, scales, channels, dimensions, context) => {\n      const x1 = dimensions.marginLeft;\n      const x2 = dimensions.width - dimensions.marginRight;\n      const y1 = 0;\n      const y2 = dimensions.height;\n      const brushed = (event) => setStartEnd(event.selection?.map(scales.x.invert));\n      const brush = d3.brushX().extent([[x1, y1], [x2, y2]]).on(\"brush end\", brushed);\n      return d3.create(\"svg:g\").call(brush).node();\n    }\n  ]\n})\n",
      "mode": "js",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 3,
      "value": "const startEnd = Mutable(null);\nconst setStartEnd = (se) => startEnd.value = se;",
      "mode": "js",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 5,
      "value": "const data = FileAttachment(\"./data/alphabet.csv\").csv({typed: true}).then(display);",
      "mode": "js",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 6,
      "value": "const calls = Object.keys(phonesTimeLineData.events).map((key) => {\n  const row = phonesTimeLineData.events[key];\n  const caller = phonesTimeLineData.entities[row.entityIds[0]];\n  return {\n    id: key,\n    caller: phonesTimeLineData.entities[row.entityIds[0]],\n    caller_type: caller.type,\n    recipient: phonesTimeLineData.entities[row.entityIds[1]],\n    start: new Date(row.time.start),\n    end: new Date(row.time.end)\n  };\n});\ndisplay(calls);\nconst callRange = {\n  start: new Date(Math.min(...calls.map(c => c.start))),\n  end: new Date(Math.max(...calls.map(c => c.end)))\n};\ndisplay(callRange);",
      "mode": "js",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 9,
      "value": "import { test } from \"./lib.js\";\n\nconst xxx = test();\ndisplay(xxx);",
      "mode": "js",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 10,
      "value": "---\n## Phones timeline",
      "mode": "md",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 11,
      "value": "const phonesTimeLineData = await FileAttachment(\"./data/phonesTimeLineData.json\").json();\ndisplay(phonesTimeLineData);",
      "mode": "js",
      "pinned": true,
      "hidden": false
    },
    {
      "id": 12,
      "value": "md`## Zoomable Timeline of Calls (${callRange.start.toLocaleDateString()} - ${callRange.end.toLocaleDateString()})`",
      "mode": "js",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 13,
      "value": "chart.element",
      "mode": "ojs",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 14,
      "value": "const timeBarData = await FileAttachment(\"./data/timeBarData.json\").json();\ndisplay(timeBarData);",
      "mode": "js",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 15,
      "value": "function renderCalls(rootNode, scaleX) {\n      const callUpdate = rootNode.selectAll(\".call\").data(calls);\n      const callEnter = callUpdate.enter().append(\"line\")\n      .attr(\"class\", \"call\")\n\n      .attr(\"stroke\", \"black\")\n      .attr(\"stroke-width\", 2);\n      const callExit = callUpdate.exit().remove();\n\n      callEnter.merge(callUpdate)\n        .attr(\"x1\", (d) => scaleX(d.start))\n        .attr(\"x2\", (d) => scaleX(d.end))\n        .attr(\"y1\", margin.top+0)\n        .attr(\"y2\", margin.top+10)\n        .text((d, i) => d.id);\n}",
      "mode": "js",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 16,
      "value": "const adjacencyList = await FileAttachment(\"./data/adjacencyList.json\").json();\ndisplay(adjacencyList);",
      "mode": "js",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 17,
      "value": "---\n\n## Entities",
      "mode": "md",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 18,
      "value": "const entityLabelToIdDict = await FileAttachment(\"./data/entityLabelToIdDict.json\").json();\ndisplay(entityLabelToIdDict);",
      "mode": "js",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 19,
      "value": "// Create a two-way dictionary from entityLabelToIdDict\nconst idToEntityLabelDict = {};\nfor (const [label, id] of Object.entries(entityLabelToIdDict)) {\n  idToEntityLabelDict[id] = label;\n}\n",
      "mode": "js",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 20,
      "value": "---\n## Calls\n",
      "mode": "md",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 21,
      "value": "const groupToChartIdsDict = await FileAttachment(\"./data/groupToChartIdsDict.json\").json();\ndisplay(groupToChartIdsDict);\nconst phonesChartData = await FileAttachment(\"./data/phonesChartData.json\").json();\ndisplay(phonesChartData);",
      "mode": "js",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 22,
      "value": "---\n## Utils",
      "mode": "md",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 23,
      "value": "Inputs.button(\"Reset zoom\", { reduce: chart.reset })",
      "mode": "ojs",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 24,
      "value": "viewof years = Inputs.range([1, 20], { value: 10, step: 1, label: \"Years\" })",
      "mode": "ojs",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 25,
      "value": "chart = Timeline(scaleX, margin, 240)",
      "mode": "ojs",
      "pinned": false,
      "hidden": true
    },
    {
      "id": 26,
      "value": "function Timeline(scaleX, margin, height = 240) {\n  let axis = {};\n  let nodes = {};\n\n  let originalScaleX = scaleX.copy();\n\n  const parts = [\"yearly\", \"daily\", \"weekly\", \"grid\", \"yearlyGrid\"];\n\n  const findDensityConfig = (map, value) => {\n    for (const [limit, config] of map) {\n      if (value < limit) {\n        return config;\n      }\n    }\n\n    return [];\n  };\n\n  const ensureTimeFormat = (value = \"\") => {\n    return typeof value !== \"function\" ? d3.utcFormat(value) : value;\n  };\n\n  axis[\"yearly\"] = (parentNode, density) => {\n    const densityMap = [\n      [\n        3,\n        [\n          d3.utcMonth,\n          (d) => {\n            const startOfTheYear =\n              d.getUTCMonth() === 0 && d.getUTCDate() === 1;\n            const format = startOfTheYear ? \"%Y â€“ %B\" : \"%B\";\n\n            return d3.utcFormat(format)(d);\n          },\n        ],\n      ],\n      [Infinity, [d3.utcYear, \"%Y\"]],\n    ];\n\n    let [interval, format] = findDensityConfig(densityMap, density);\n    format = ensureTimeFormat(format);\n\n    const el = parentNode\n      .attr(\"transform\", `translate(0,${margin.top - 48})`)\n      .call(\n        d3\n          .axisTop(scaleX)\n          .ticks(interval)\n          .tickFormat(format)\n          .tickSizeOuter(0)\n      );\n\n    el.select(\".domain\").remove();\n\n    el.selectAll(\"text\")\n      .attr(\"y\", 0)\n      .attr(\"x\", 6)\n      .style(\"text-anchor\", \"start\");\n\n    el.selectAll(\"line\").attr(\"y1\", -7).attr(\"y2\", 6);\n  };\n\n  axis[\"daily\"] = (parentNode, density) => {\n    const densityMap = [\n      [1, [d3.utcDay, \"%-d\"]],\n      [3, [d3.utcDay, \"\"]],\n      [8, [d3.utcMonth, \"%B\"]],\n      [13, [d3.utcMonth, \"%b\"]],\n      [22, [d3.utcMonth, (d) => d3.utcFormat(\"%B\")(d).charAt(0)]],\n      [33, [d3.utcMonth.every(3), \"Q%q\"]],\n      [Infinity, [d3.utcMonth.every(3), \"\"]],\n    ];\n\n    let [interval, format] = findDensityConfig(densityMap, density);\n    format = ensureTimeFormat(format);\n\n    const el = parentNode\n      .attr(\"transform\", `translate(0,${margin.top - 28})`)\n      .call(\n        d3\n          .axisTop(scaleX)\n          .ticks(interval)\n          .tickFormat(format)\n          .tickSizeOuter(0)\n      );\n\n    el.select(\".domain\").remove();\n\n    el.selectAll(\"text\")\n      .attr(\"y\", 0)\n      .attr(\"x\", 6)\n      .style(\"text-anchor\", \"start\");\n\n    el.selectAll(\"line\").attr(\"y1\", -7).attr(\"y2\", 0);\n  };\n\n  axis[\"weekly\"] = (parentNode, density) => {\n    const densityMap = [\n      [10, [d3.utcMonday, (d) => +d3.utcFormat(\"%-V\")(d)]],  // monday as first of week and zero based\n      [33, [d3.utcMonday, \"\"]],\n      [Infinity, [d3.utcMonday.every(4), \"\"]],\n    ];\n\n    let [interval, format] = findDensityConfig(densityMap, density);\n    format = ensureTimeFormat(format);\n\n    const el = parentNode\n      .attr(\"transform\", `translate(0,${margin.top - 8})`)\n      .call(\n        d3\n          .axisTop(scaleX)\n          .ticks(interval)\n          .tickFormat(format)\n          .tickSizeOuter(0)\n      );\n\n    el.select(\".domain\").remove();\n    el.selectAll(\"line\").style(\n      \"visibility\",\n      density > densityMap[0][0] ? \"visible\" : \"hidden\"\n    );\n\n    el.selectAll(\"text\")\n      .attr(\"y\", 0)\n      .attr(\"x\", 6)\n      .style(\"text-anchor\", \"start\");\n\n    el.selectAll(\"line\").attr(\"y1\", -7).attr(\"y2\", 0);\n  };\n\n  axis[\"grid\"] = (parentNode, density) => {\n    const densityMap = [\n      [1, [d3.utcDay]],\n      [8, [d3.utcMonday]],\n      [22, [d3.utcMonth]],\n      [Infinity, [d3.utcMonth.every(3)]],\n    ];\n\n    const [interval] = findDensityConfig(densityMap, density);\n\n    const el = parentNode\n      .attr(\"transform\", `translate(0,${margin.top})`)\n      .call(d3.axisTop(scaleX).ticks(interval).tickSizeOuter(0));\n\n    el.select(\".domain\").remove();\n    el.selectAll(\"text\").remove();\n\n    el.selectAll(\"line\")\n      .attr(\"y1\", 0)\n      .attr(\"y2\", height - margin.top - margin.bottom);\n  };\n\n  axis[\"yearlyGrid\"] = (parentNode, density) => {\n    const densityMap = [\n      [3, [d3.utcMonth, \"%B\"]],\n      [Infinity, [d3.utcYear, \"%Y\"]],\n    ];\n\n    let [interval, format] = findDensityConfig(densityMap, density);\n    format = ensureTimeFormat(format);\n\n    const el = parentNode\n      .attr(\"transform\", `translate(0,${margin.top})`)\n      .call(\n        d3\n          .axisTop(scaleX)\n          .ticks(interval)\n          .tickFormat(format)\n          .tickSizeOuter(0)\n      );\n\n    el.select(\".domain\").remove();\n    el.selectAll(\"text\").remove();\n\n    el.selectAll(\"line\")\n      .attr(\"y1\", 0)\n      .attr(\"y2\", height - margin.top - margin.bottom);\n  };\n\n  const setup = () => {\n    const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .classed(\"timeline\", true)\n      .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n    const element = svg.node();\n\n    const rootNode = svg.append(\"g\").classed(\"timeline-axis\", true);\n\n    parts.forEach((part) => {\n      nodes[part] = rootNode.append(\"g\").classed(part, true);\n    });\n\n    const update = () => {\n      const density = Math.abs(scaleX.invert(0) - scaleX.invert(1)) / MS_PER_HOUR; // in pixels per hour\n\n      parts.forEach((part) => {\n        nodes[part].call(axis[part], density);\n      });\n\n      renderCalls(rootNode, scaleX);\n    };\n\n    const { zoom, reset } = zoomPlugin(svg,\n      ({ transform }) => {\n        scaleX = transform.rescaleX(originalScaleX);\n\n        update();\n      }\n    );\n\n    update();\n\n    return {\n      element,\n      update,\n      reset,\n    };\n  };\n\n  return setup();\n}",
      "mode": "ojs",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 27,
      "value": "function zoomPlugin(svg, zoomed) {\n  const zoom = d3.zoom()\n    .scaleExtent(zoomScaleExtent)\n    .extent([[margin.left, 0], [width - margin.right, 0]])\n    .translateExtent([\n      [margin.left, 0],\n      [width - margin.right, 0]\n    ])\n    .filter(filter)\n    .on(\"zoom\", zoomed);\n\n  svg.call(zoom);\n\n  function reset() {\n    svg.transition()\n      .duration(750)\n      .call(zoom.transform, d3.zoomIdentity);\n  }\n\n  // prevent scrolling then apply the default filter\n  function filter(event) {\n    event.preventDefault();\n    return (!event.ctrlKey || event.type === 'wheel') && !event.button;\n  }\n\n  return {\n    zoom,\n    reset\n  };\n}",
      "mode": "js",
      "pinned": false,
      "hidden": true
    },
    {
      "id": 28,
      "value": "function getDate(date) {\n  return new Date(date.toISOString().split('T')[0]);\n}\n\nconst now = callRange.start;\nconst until = callRange.end;\n\nconst nowDate = new Date(callRange.start.getUTCFullYear(), 0, 1);\nconst untilDate = new Date(callRange.end.getUTCFullYear(), 11, 31);\n\nconst scaleX = d3.scaleUtc().domain([nowDate, untilDate]).range([margin.left, width - margin.right]);",
      "mode": "js",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 29,
      "value": "scaleX.domain()",
      "mode": "ojs",
      "pinned": true,
      "hidden": false
    },
    {
      "id": 30,
      "value": "function getDays(a, b) { return Math.abs(a - b) / MS_PER_DAY; }",
      "mode": "js",
      "pinned": false,
      "hidden": true
    },
    {
      "id": 31,
      "value": "days = getDays(...scaleX.domain())",
      "mode": "ojs",
      "pinned": false,
      "hidden": true
    },
    {
      "id": 32,
      "value": "zoomScaleExtent = [1, Math.round(days)]",
      "mode": "ojs",
      "pinned": false,
      "hidden": true
    },
    {
      "id": 33,
      "value": "margin = ({ top: 80, right: 20, bottom: 20, left: 20 });",
      "mode": "ojs",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 34,
      "value": "MS_PER_DAY = 24 * MS_PER_HOUR;",
      "mode": "ojs",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 35,
      "value": "MS_PER_HOUR = 60 * 60 * 1000;",
      "mode": "ojs",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 36,
      "value": "MS_PER_YEAR = 365.24 * MS_PER_DAY; // include leap year",
      "mode": "ojs",
      "pinned": false,
      "hidden": false
    },
    {
      "id": 37,
      "value": "html`\n<style type=\"text/css\">\n  .timeline {\n    --background-color: #334155;\n    --daily-gridline-color: #cbd5e1;\n    --yearly-gridline-color: #e2e8f0;\n    --yearly-tick-color: #e2e8f0;\n    --yearly-label-color: #f8fafc;\n    --daily-tick-color: #e2e8f0;\n    --daily-label-color: #f8fafc;\n    --weekly-tick-color: #e2e8f0;\n    --weekly-label-color: #f8fafc;\n\n    background-color: var(--background-color);\n    border-radius: 0.25rem;\n  }\n\n  .calls-layer line.call-line {\n    stroke: #38bdf8;\n    stroke-width: 2;\n    stroke-linecap: round;\n    opacity: 0.9;\n  }\n  .calls-layer circle {\n    fill: #f472b6;\n    stroke: #0f172a;\n    stroke-width: 1;\n  }\n  .calls-layer g.call:hover line.call-line {\n    stroke: #fbbf24;\n  }\n  .calls-layer g.call:hover circle {\n    fill: #fbbf24;\n  }\n\n  .timeline-axis line {\n    shape-rendering: geometricPrecision;\n    stroke-width: 0.5;\n  }\n\n  .timeline-axis .yearly line {\n    stroke: var(--yearly-tick-color);\n  }\n\n  .timeline-axis .yearly text {\n    color: var(--yearly-label-color);\n  }\n\n  .timeline-axis .daily line {\n    stroke: var(--daily-tick-color);\n  }\n\n  .timeline-axis .daily text {\n    color: var(--daily-label-color);\n  }\n\n  .timeline-axis .weekly line {\n    stroke: var(--weekly-tick-color);\n  }\n\n  .timeline-axis .weekly text {\n    color: var(--weekly-label-color);\n  }\n\n  .timeline-axis .grid line {\n    stroke: var(--daily-gridline-color);\n  }\n\n  .timeline-axis .yearlyGrid line {\n    stroke: var(--yearly-gridline-color);\n  }\n</style>\n`",
      "mode": "ojs",
      "pinned": false,
      "hidden": false
    }
  ],
  "title": "reactive-demo",
  "theme": "slate",
  "readOnly": false
};
export default notebook;
