// Generated by vscode-ojs: Observable Notebook Kit compiled definitions

function cell_1(md, filteredCalls) {

return (
md`## Phone Call Dashbord

_Current selection count:  ${filteredCalls.length}_
`
)

}
function cell_2(display, timeline) {

display(timeline.element);

}
async function cell_3(html, width, display) {

const { GraphHtml } = await import("https://cdn.jsdelivr.net/npm/@hpcc-js/graph/+esm").then((module) => {
if (!("GraphHtml" in module)) throw new SyntaxError(`export 'GraphHtml' not found`);
return module;
});


const placeholder = html`<div style="height:400px;width:${width};padding-bottom:10px"></div>`;
display(placeholder);
const graph = new GraphHtml()
.target(placeholder)
.on("vertex_click", (row, col, sel) => console.log("click", row, col, sel))
.on("vertex_dblclick", (row, col, sel) => console.log("dblclick", row, col, sel))
.on("vertex_mousein", (row, col, sel) => console.log("mousein", row, col, sel))
.on("vertex_mouseover", (row, col, sel) => console.log("mouseover", row, col, sel))
.on("vertex_mouseout", (row, col, sel) => console.log("mouseout", row, col, sel))
;
return {GraphHtml,placeholder,graph};

}
function cell_4(d3) {

function binCalls(calls) {
const [minDate, maxDate] = d3.extent(calls, d => d.start);
const dayThresholds = d3.timeDay.range(
d3.timeDay.floor(minDate),
d3.timeDay.offset(d3.timeDay.floor(maxDate), 1)
);
const dayBins = d3.bin()
.value(d => +d.start)
.thresholds(dayThresholds)(calls);
return dayBins.map(b => ({ day: new Date(b.x0), count: b.length }));
}
return {binCalls};

}
function cell_5(binCalls, calls) {

const binnedCalls = binCalls(calls);
return {binnedCalls};

}
function cell_6(binCalls, filteredCalls) {

const filteredBinnedCalls = binCalls(filteredCalls);
return {filteredBinnedCalls};

}
function cell_7(Plot, binnedCalls, setStartEnd, d3) {

return (
Plot.plot({
width: 960,
height: 200,
x: { type: "utc", label: "Day", labelAnchor: "right" },
y: { grid: true, label: "# Calls" },

marks: [
  Plot.areaY(binnedCalls, { x: "day", y: "count", curve: "catmull-rom", fillOpacity: 0.2 }),
  Plot.lineY(binnedCalls, { x: "day", y: "count", curve: "catmull-rom" }),
  Plot.ruleY([0]),
  (index, scales, channels, dimensions, context) => {
    const x1 = dimensions.marginLeft;
    const x2 = dimensions.width - dimensions.marginRight;
    const y1 = dimensions.marginTop;
    const y2 = dimensions.height - dimensions.marginBottom;
    const brushed = (event) => setStartEnd(event.selection?.map(scales.x.invert));
    const brush = d3.brushX().extent([[x1, y1], [x2, y2]]).on("brush end", brushed);
    return d3.create("svg:g").call(brush).node();
  }
]
})
)

}
function cell_8(Inputs, filteredCalls, backColor, phoneIdToEntityDict, formatDuration) {

return (
Inputs.table(filteredCalls, {
columns: ["start", "caller_id", "callee_id", "duration"],
header: {
  start: "When",
  caller_id: "By",
  callee_id: "To",
  duration: "Duration",
},
format: {
  start: (d) => d.toLocaleDateString() + " " + d.toLocaleTimeString(),
  caller_id: (d) => backColor(phoneIdToEntityDict[d]) ?? d,
  callee_id: (d) => backColor(phoneIdToEntityDict[d]) ?? d,
  duration: (d) => formatDuration(d),
}
})
)

}
function cell_9(md) {

return (
md`---

## Rough Work

_GJS rough work_
`
)

}
function cell_10(md) {

return (
md`
### Table Helpers`
)

}
function cell_11(Mutable, calls, start, end) {

const filteredCallsMap = Mutable({});
const filteredCalls = calls.filter((d, idx) => {
if (idx === 0) {
  filteredCallsMap.value = {};
}
const retVal = (!start || d.start >= start) && (!end || d.start < end);
if (retVal) {
  filteredCallsMap.value[d.caller_id] = true;
  filteredCallsMap.value[d.callee_id] = true;
}
return retVal;
});
return {filteredCallsMap,filteredCalls};

}
function cell_12(display, filteredCallsMap, filteredCalls) {

display(filteredCallsMap);
display(filteredCalls);

}
function cell_13() {

function formatDuration(ms) {
if (ms == null || isNaN(ms)) return "";
const totalSeconds = Math.max(0, Math.round(ms / 1000));
const minutes = Math.floor(totalSeconds / 60);
const seconds = totalSeconds % 60;
if (minutes === 0) return seconds + "s";
return minutes + "m " + seconds + "s";
}
return {formatDuration};

}
function cell_14(d3, htl, phoneEntityTypeToTypeDict) {

function readableColor(backgroundColor) {
const rgb = d3.rgb(backgroundColor);
const brightness = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
return brightness > 128 ? "black" : "white";
}

function backColor(entity) {
return htl.html`<div style="background: ${phoneEntityTypeToTypeDict[entity.type].color};color: ${readableColor(phoneEntityTypeToTypeDict[entity.type].color)};padding: 0 0.5rem;justify-content: end;">${entity.label}</div>`
}
return {readableColor,backColor};

}
function cell_15(Mutable) {

const start = Mutable(null);
const end = Mutable(null);
const setStartEnd = (se) => {
start.value = se[0];
end.value = se[1];
}
return {start,end,setStartEnd};

}
function cell_16(md) {

return (
md`---

### Graph Helpers`
)

}
function cell_17(graph) {

graph
.dragSingleNeighbors(true)
.edgeColor("#287EC4")
.edgeStrokeWidth(1.66)
.edgeArcDepth(2.5)
.forceDirectedAlphaDecay(0.01)
.layout("ForceDirectedHybrid")
.applyScaleOnLayout(true)
.lazyRender()
;

}
function cell_18(adjacencyList, phoneIdToEntityDict, phoneEntityTypeToTypeDict) {

const idxMap = {};
const edgeIdxMap = {};
const edges = [];

const vertices = Object.keys(adjacencyList).map((key, idx) => {
const entity = phoneIdToEntityDict[+key];
const categoryColor = phoneEntityTypeToTypeDict[entity.type].color;
const vertex = {
  categoryID: entity.type,
  id: +key,
  text: entity.label,
  icon: {
    imageChar: "fa-user",
    height: 32,
    fill: categoryColor,
  }
}
vertex.textBoxAnnotationsS = [{
  text: "fa-star",
  fill: "red",
  stroke: "darkred"
}];
idxMap[+key] = vertex;

const links = adjacencyList[key];
Object.keys(links).forEach((link, idx) => {
  const id = +key < +link ? `${key}-${link}` : `${link}-${key}`;
  const edge = {
    id,
    source: +key,
    target: +link,
    __calls: links[link],
  };
  if (edgeIdxMap[edge.id]) {
    edgeIdxMap[edge.id].__calls.push(...edge.__calls);
  } else {
    edgeIdxMap[edge.id] = edge;
  }
});

return vertex;
});

Object.values(edgeIdxMap).forEach((edge) => {
edge.source = idxMap[edge.source];
edge.target = idxMap[edge.target];
if (edge.source && edge.target) {
  edge.text = `#${edge.__calls.length}`
  edges.push(edge);
}
});
return {idxMap,edgeIdxMap,edges,vertices};

}
function cell_19(graph, vertices, edges, filteredCallsMap) {

graph
.data({ vertices, edges })
.highlightVerticies(filteredCallsMap)
.lazyRender()
;

}
function cell_20(phonesTimeLineData, display) {

const calls = Object.keys(phonesTimeLineData.events).map((key) => {
const row = phonesTimeLineData.events[key];
const caller = phonesTimeLineData.entities[row.entityIds[0]];
return {
  id: key,
  caller_id: +row.entityIds[0],
  callee_id: +row.entityIds[1],
  caller_type: caller.type,
  start: new Date(row.time.start),
  end: new Date(row.time.end),
  duration: new Date(row.time.end) - new Date(row.time.start)
};
});
display(calls);
const callRange = {
start: new Date(Math.min(...calls.map(c => c.start))),
end: new Date(Math.max(...calls.map(c => c.end)))
};
display(callRange);
return {calls,callRange};

}
async function cell_21(display) {

const { test } = await import("./lib.js").then((module) => {
if (!("test" in module)) throw new SyntaxError(`export 'test' not found`);
return module;
});

const xxx = test();
display(xxx);
return {test,xxx};

}
function cell_22(md) {

return (
md`---

## Timeline Helpers
`
)

}
function cell_23(phonesTimeLineData, display) {

const phoneIdToEntityDict = {};
for (const [id, entity] of Object.entries(phonesTimeLineData.entities)) {
phoneIdToEntityDict[+id] = entity;
}
display(phoneIdToEntityDict);

const phoneEntityTypeToTypeDict = {};
for (const [id, entity] of Object.entries(phonesTimeLineData.entityTypes)) {
phoneEntityTypeToTypeDict[id] = entity;
}
display(phoneEntityTypeToTypeDict);
return {phoneIdToEntityDict,phoneEntityTypeToTypeDict};

}
function cell_24(entityLabelToIdDict, display) {

const idToEntityLabelDict = {};
for (const [label, id] of Object.entries(entityLabelToIdDict)) {
idToEntityLabelDict[+id] = label;
}
display(idToEntityLabelDict);
return {idToEntityLabelDict};

}
function cell_25(callRange, d3, margin, width) {

function getDate(date) {
return new Date(date.toISOString().split('T')[0]);
}

const now = callRange.start;
const until = callRange.end;

const nowDate = new Date(callRange.start.getUTCFullYear(), 0, 1);
const untilDate = new Date(callRange.end.getUTCFullYear(), 11, 31);

const scaleX = d3.scaleUtc().domain([nowDate, untilDate]).range([margin.left, width - margin.right]);
return {getDate,now,until,nowDate,untilDate,scaleX};

}
function cell_26() {

const margin = ({ top: 80, right: 20, bottom: 20, left: 20 });
return {margin};

}
function cell_27(Timeline, timelineData, scaleX) {

const timeline = Timeline(timelineData, {
from: scaleX.domain()[0],
until: scaleX.domain()[1]
})
return {timeline};

}
function cell_28(d3, width, dodge) {

function Timeline(data, options) {
const axis = {};
const nodes = {};
let _data = data;

const { from, until, margin, height, onClickItem, onZoomEnd, zoomFilter } = {
  from: new Date().setFullYear(new Date().getFullYear() + 1),
  until: new Date().setFullYear(new Date().getFullYear() + 1),
  margin: { top: 80, right: 20, bottom: 20, left: 20 },
  height: 200,
  onClickItem: () => { },
  onZoomEnd: () => { },
  zoomFilter: () => { },
  ...options
};

const MS_PER_HOUR = 60 * 60 * 1000;
const MS_PER_SECOND = 1000;
const MS_PER_DAY = 24 * MS_PER_HOUR;
const MS_PER_YEAR = 365.24 * MS_PER_DAY; // include leap year

const parts = ["yearly", "daily", "weekly", "grid", "yearlyGrid"];

let scaleX = d3
  .scaleUtc()
  .domain([from, until])
  .range([margin.left, width - margin.right]);

const originalScaleX = scaleX.copy();

const density = Math.abs(scaleX.invert(0) - scaleX.invert(1)) / MS_PER_HOUR; // in pixels per hour

const zoomScaleExtent = [1, Math.round(MS_PER_YEAR * 10)];

const findDensityConfig = (map, value) => {
  for (const [limit, config] of map) {
    if (value < limit) {
      return config;
    }
  }

  return [];
};

const ensureTimeFormat = (value = "") => {
  return typeof value !== "function" ? d3.utcFormat(value) : value;
};

axis["yearly"] = (parentNode, density) => {
  const densityMap = [
    [0.0005, [d3.utcHour, "%B %-d, %Y %H:%M"]],
    [0.05, [d3.utcDay, "%B %-d, %Y"]],
    [
      3,
      [
        d3.utcMonth,
        (d) => {
          const startOfTheYear =
            d.getUTCMonth() === 0 && d.getUTCDate() === 1;
          const format = startOfTheYear ? "%Y – %B" : "%B";

          return d3.utcFormat(format)(d);
        }
      ]
    ],
    [Infinity, [d3.utcYear, "%Y"]]
  ];

  let [interval, format] = findDensityConfig(densityMap, density);
  format = ensureTimeFormat(format);

  const el = parentNode
    .attr("transform", `translate(0,${margin.top - 48})`)
    .call(
      d3.axisTop(scaleX).ticks(interval).tickFormat(format).tickSizeOuter(0)
    );

  el.select(".domain").remove();

  el.selectAll("text")
    .attr("y", 0)
    .attr("x", 6)
    .style("text-anchor", "start");

  el.selectAll("line").attr("y1", -7).attr("y2", 6);
};

axis["daily"] = (parentNode, density) => {
  const densityMap = [
    [0.0005, [d3.utcMinute, "%M"]],
    [0.05, [d3.utcHour, "%H"]],
    [1, [d3.utcDay, "%-d"]],
    [3, [d3.utcDay, ""]],
    [8, [d3.utcMonth, "%B"]],
    [13, [d3.utcMonth, "%b"]],
    [22, [d3.utcMonth, (d) => d3.utcFormat("%B")(d).charAt(0)]],
    [33, [d3.utcMonth.every(3), "Q%q"]],
    [Infinity, [d3.utcMonth.every(3), ""]]
  ];

  let [interval, format] = findDensityConfig(densityMap, density);
  format = ensureTimeFormat(format);

  const el = parentNode
    .attr("transform", `translate(0,${margin.top - 28})`)
    .call(
      d3.axisTop(scaleX).ticks(interval).tickFormat(format).tickSizeOuter(0)
    );

  el.select(".domain").remove();

  el.selectAll("text")
    .attr("y", 0)
    .attr("x", 6)
    .style("text-anchor", "start");

  el.selectAll("line").attr("y1", -7).attr("y2", 0);
};

axis["weekly"] = (parentNode, density) => {
  const densityMap = [
    [10, [d3.timeMonday, (d) => +d3.utcFormat("%-W")(d) + 1]], // monday as first of week and zero based
    [33, [d3.timeMonday, ""]],
    [Infinity, [d3.timeMonday.every(4), ""]]
  ];

  let [interval, format] = findDensityConfig(densityMap, density);
  format = ensureTimeFormat(format);

  const el = parentNode
    .attr("transform", `translate(0,${margin.top - 8})`)
    .call(
      d3.axisTop(scaleX).ticks(interval).tickFormat(format).tickSizeOuter(0)
    );

  el.select(".domain").remove();
  el.selectAll("line").style(
    "visibility",
    density > densityMap[0][0] ? "visible" : "hidden"
  );

  el.selectAll("text")
    .attr("y", 0)
    .attr("x", 6)
    .style("text-anchor", "start");

  el.selectAll("line").attr("y1", -7).attr("y2", 0);
};

axis["grid"] = (parentNode, density) => {
  const densityMap = [
    [0.001, [d3.utcMinute]],
    [0.025, [d3.utcMinute.every(30)]],
    [0.05, [d3.utcHour]],
    [0.5, [d3.utcHour.every(6)]],
    [1, [d3.utcDay]],
    [8, [d3.timeMonday]],
    [22, [d3.utcMonth]],
    [Infinity, [d3.utcMonth.every(3)]]
  ];

  const [interval] = findDensityConfig(densityMap, density);

  const el = parentNode
    .attr("transform", `translate(0,${margin.top})`)
    .call(d3.axisTop(scaleX).ticks(interval).tickSizeOuter(0));

  el.select(".domain").remove();
  el.selectAll("text").remove();

  el.selectAll("line")
    .attr("stroke-width", 0.5)
    .attr("y1", 0)
    .attr("y2", height - margin.top - margin.bottom);
};

axis["yearlyGrid"] = (parentNode, density) => {
  const densityMap = [
    [3, [d3.utcMonth, "%B"]],
    [Infinity, [d3.utcYear, "%Y"]]
  ];

  let [interval, format] = findDensityConfig(densityMap, density);
  format = ensureTimeFormat(format);

  const el = parentNode
    .attr("transform", `translate(0,${margin.top})`)
    .call(
      d3.axisTop(scaleX).ticks(interval).tickFormat(format).tickSizeOuter(0)
    );

  el.select(".domain").remove();
  el.selectAll("text").remove();

  el.selectAll("line")
    .attr("y1", 0)
    .attr("y2", height - margin.top - margin.bottom);
};

const setup = () => {
  const svg = d3
    .create("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("viewBox", [0, 0, width, height])
    .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

  const element = svg.node();

  const rootNode = svg.append("g").classed("timeline-axis", true);

  parts.forEach((part) => {
    nodes[part] = rootNode.append("g").classed(part, true);
  });

  const radius = 4;
  const padding = 1;

  const bind = (data) => {
    const I = d3.range(data.length);
    const X = data.map((d) => scaleX(d.day));
    const Y = dodge(X, radius * 2 + padding);
    const countExtent = d3.extent(data, (d) => d.count);
    const color = d3.scaleSequential(d3.interpolateBuPu).domain(countExtent);
    const items = svg
      .selectAll("circle")
      .data(data)
      .join(
        (enter) =>
          enter
            .append("circle")
            .on("click", onClickItem)
            // .style("stroke", "white")
            // .style("stroke-width", 1)
            .style("fill", (d) => color(d.count))
            .style("cursor", "pointer")
            .attr("r", 4)
            .attr("cx", (d, i) => X[i])
            .attr("cy", (d, i) => Y[i] + 120)
            .append("title")
            .text((d) => d.id),
        (update) =>
          update.style("fill", (d) => color(d.count)).attr("cx", (d, i) => X[i]).attr("cy", (d, i) => Y[i] + 130)
      );

    const density =
      Math.abs(scaleX.invert(0) - scaleX.invert(1)) / MS_PER_HOUR; // in pixels per hour

    parts.forEach((part) => {
      nodes[part].call(axis[part], density);
    });
    return items;
  };

  const getBounds = () => {
    return { start: scaleX.domain()[0], end: scaleX.domain()[1] };
  };

  const items = bind(data);

  const zoom = d3
    .zoom()
    .scaleExtent(zoomScaleExtent)
    .extent([
      [margin.left, 0],
      [width - margin.right, 0]
    ])
    .translateExtent([
      [margin.left, 0],
      [width - margin.right, 0]
    ])
    .on("zoom", ({ transform }) => {
      scaleX = transform.rescaleX(originalScaleX);
      bind(_data);
      element.value = {
        start: scaleX.domain()[0],
        end: scaleX.domain()[1]
      };
      element.dispatchEvent(new CustomEvent("input"));
    });
  svg.call(zoom);

  const update = (data) => {
    _data = data;
    bind(_data);
  };

  return {
    element,
    update,
    items,
    getBounds
  };
};

return setup();
}
return {Timeline};

}
function cell_29(d3) {

function dodge(X, radius) {
const Y = new Float64Array(X.length);
const radius2 = radius ** 2;
const epsilon = 1e-3;
let head = null,
  tail = null;

// Returns true if circle ⟨x, y⟩ intersects with any circle in the queue.
const intersects = (x, y) => {
  let a = head;
  while (a) {
    const ai = a.index;
    if (radius2 - epsilon > (X[ai] - x) ** 2 + (Y[ai] - y) ** 2) return true;
    a = a.next;
  }
  return false;
};

// Place each circle sequentially.
for (const bi of d3.range(X.length).sort((i, j) => X[i] - X[j])) {
  while (head && X[head.index] < X[bi] - radius2) head = head.next; // Remove non-intersecting

  // Start by attempting to place at y = 0, check for intersections.
  Y[bi] = 0;
  if (intersects(X[bi], Y[bi])) {
    let a = head;
    Y[bi] = Infinity; // Start with a high Y value which will be minimized.

    do {
      const ai = a.index;
      const distX = X[ai] - X[bi];
      const distToEdge = Math.sqrt(radius2 - distX * distX);

      // Check above each circle
      let y1 = Y[ai] + distToEdge;
      if (Math.abs(y1) < Math.abs(Y[bi]) && !intersects(X[bi], y1))
        Y[bi] = y1;

      // Check below each circle
      let y2 = Y[ai] - distToEdge;
      if (Math.abs(y2) < Math.abs(Y[bi]) && !intersects(X[bi], y2))
        Y[bi] = y2;

      a = a.next;
    } while (a);
  }

  // Add b to the queue.
  const b = { index: bi, next: null };
  if (head === null) head = tail = b;
  else tail = tail.next = b;
}

return Y;
}
return {dodge};

}
function cell_30(Plot, d3) {

function beeswarm(
data,
{ gap = 1, ticks = 50, dynamic = false, direction, ...options }
) {
const dots = Plot.dot(data, options);
const { render } = dots;

dots.render = function () {
  const g = render.apply(this, arguments);
  const circles = d3.select(g).selectAll("circle");

  const nodes = [];
  const [cx, cy, x, y, forceX, forceY] =
    direction === "x"
      ? ["cx", "cy", "x", "y", d3.forceX, d3.forceY]
      : ["cy", "cx", "y", "x", d3.forceY, d3.forceX];
  for (const c of circles) {
    const node = {
      x: +c.getAttribute(cx),
      y: +c.getAttribute(cy),
      r: +c.getAttribute("r")
    };
    nodes.push(node);
  }
  const force = d3
    .forceSimulation(nodes)
    .force("x", forceX((d) => d[x]).strength(0.8))
    .force("y", forceY((d) => d[y]).strength(0.05))
    .force(
      "collide",
      d3
        .forceCollide()
        .radius((d) => d.r + gap)
        .iterations(3)
    )
    .tick(ticks)
    .stop();
  update();
  if (dynamic) force.on("tick", update).restart();
  return g;

  function update() {
    circles.attr(cx, (_, i) => nodes[i].x).attr(cy, (_, i) => nodes[i].y);
  }
};

return dots;
}
return {beeswarm};

}
function cell_31(filteredBinnedCalls, display) {

const timelineData = filteredBinnedCalls.map((x, i) => ({
id: i,
day: x.day,
count: x.count
}))
display(timelineData);
return {timelineData};

}
function cell_32(html) {

return (
html`
<style type="text/css">
  .timeline-axis {
    --daily-gridline-color: rgb(194, 199, 200);
    --yearly-gridline-color: rgb(81, 93, 93);
    --yearly-tick-color: rgb(81, 93, 93);
    --yearly-label-color: rgb(60, 79, 81);
    --daily-tick-color: rgb(161, 173, 173);
    --daily-label-color: rgb(60, 79, 81);
    --weekly-tick-color: rgb(161, 173, 173);
    --weekly-label-color: rgb(60, 79, 81);
  }

  .timeline-axis line {
    shape-rendering: geometricPrecision;
    stroke-width: 0.5;
  }

  .timeline-axis .yearly line {
    stroke: var(--yearly-tick-color);
  }

  .timeline-axis .yearly text {
    color: var(--yearly-label-color);
  }

  .timeline-axis .daily line {
    stroke: var(--daily-tick-color);
  }

  .timeline-axis .daily text {
    color: var(--daily-label-color);
  }

  .timeline-axis .weekly line {
    stroke: var(--weekly-tick-color);
  }

  .timeline-axis .weekly text {
    color: var(--weekly-label-color);
  }

  .timeline-axis .grid line {
    stroke: var(--daily-gridline-color);
  }

  .timeline-axis .yearlyGrid line {
    stroke: var(--yearly-gridline-color);
  }
</style>
`
)

}
function cell_33(md) {

return (
md`---
`
)

}
function cell_34(md) {

return (
md`
### Data Loaders
`
)

}
async function cell_35(FileAttachment, display) {

const adjacencyList = await FileAttachment("./data/adjacencyList.json").json().then(display);
return {adjacencyList};

}
async function cell_36(FileAttachment, display) {

const timeBarData = await FileAttachment("./data/timeBarData.json").json().then(display);
return {timeBarData};

}
async function cell_37(FileAttachment, display) {

const groupToChartIdsDict = await FileAttachment("./data/groupToChartIdsDict.json").json().then(display);
return {groupToChartIdsDict};

}
async function cell_38(FileAttachment, display) {

const phonesChartData = await FileAttachment("./data/phonesChartData.json").json().then(display);
return {phonesChartData};

}
async function cell_39(FileAttachment, display) {

const entityLabelToIdDict = await FileAttachment("./data/entityLabelToIdDict.json").json().then(display);
return {entityLabelToIdDict};

}
async function cell_40(FileAttachment, display) {

const phonesTimeLineData = await FileAttachment("./data/phonesTimeLineData.json").json().then(display);
return {phonesTimeLineData};

}
const definitions = [
{
    "id": 1,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_1,
    "inputs": [
        "md",
        "filteredCalls"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 2,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_2,
    "inputs": [
        "display",
        "timeline"
    ],
    "outputs": [],
    "autodisplay": false
},
{
    "id": 3,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_3,
    "inputs": [
        "html",
        "width",
        "display"
    ],
    "outputs": [
        "GraphHtml",
        "placeholder",
        "graph"
    ],
    "autodisplay": false
},
{
    "id": 4,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_4,
    "inputs": [
        "d3"
    ],
    "outputs": [
        "binCalls"
    ],
    "autodisplay": false
},
{
    "id": 5,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_5,
    "inputs": [
        "binCalls",
        "calls"
    ],
    "outputs": [
        "binnedCalls"
    ],
    "autodisplay": false
},
{
    "id": 6,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_6,
    "inputs": [
        "binCalls",
        "filteredCalls"
    ],
    "outputs": [
        "filteredBinnedCalls"
    ],
    "autodisplay": false
},
{
    "id": 7,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_7,
    "inputs": [
        "Plot",
        "binnedCalls",
        "setStartEnd",
        "d3"
    ],
    "outputs": [],
    "autodisplay": true
},
{
    "id": 8,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_8,
    "inputs": [
        "Inputs",
        "filteredCalls",
        "backColor",
        "phoneIdToEntityDict",
        "formatDuration"
    ],
    "outputs": [],
    "autodisplay": true
},
{
    "id": 9,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_9,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 10,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_10,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 11,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_11,
    "inputs": [
        "Mutable",
        "calls",
        "start",
        "end"
    ],
    "outputs": [
        "filteredCallsMap",
        "filteredCalls"
    ],
    "autodisplay": false
},
{
    "id": 12,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_12,
    "inputs": [
        "display",
        "filteredCallsMap",
        "filteredCalls"
    ],
    "outputs": [],
    "autodisplay": false
},
{
    "id": 13,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_13,
    "inputs": [],
    "outputs": [
        "formatDuration"
    ],
    "autodisplay": false
},
{
    "id": 14,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_14,
    "inputs": [
        "d3",
        "htl",
        "phoneEntityTypeToTypeDict"
    ],
    "outputs": [
        "readableColor",
        "backColor"
    ],
    "autodisplay": false
},
{
    "id": 15,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_15,
    "inputs": [
        "Mutable"
    ],
    "outputs": [
        "start",
        "end",
        "setStartEnd"
    ],
    "autodisplay": false
},
{
    "id": 16,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_16,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 17,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_17,
    "inputs": [
        "graph"
    ],
    "outputs": [],
    "autodisplay": false
},
{
    "id": 18,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_18,
    "inputs": [
        "adjacencyList",
        "phoneIdToEntityDict",
        "phoneEntityTypeToTypeDict"
    ],
    "outputs": [
        "idxMap",
        "edgeIdxMap",
        "edges",
        "vertices"
    ],
    "autodisplay": false
},
{
    "id": 19,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_19,
    "inputs": [
        "graph",
        "vertices",
        "edges",
        "filteredCallsMap"
    ],
    "outputs": [],
    "autodisplay": false
},
{
    "id": 20,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_20,
    "inputs": [
        "phonesTimeLineData",
        "display"
    ],
    "outputs": [
        "calls",
        "callRange"
    ],
    "autodisplay": false
},
{
    "id": 21,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_21,
    "inputs": [
        "display"
    ],
    "outputs": [
        "test",
        "xxx"
    ],
    "autodisplay": false
},
{
    "id": 22,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_22,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 23,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_23,
    "inputs": [
        "phonesTimeLineData",
        "display"
    ],
    "outputs": [
        "phoneIdToEntityDict",
        "phoneEntityTypeToTypeDict"
    ],
    "autodisplay": false
},
{
    "id": 24,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_24,
    "inputs": [
        "entityLabelToIdDict",
        "display"
    ],
    "outputs": [
        "idToEntityLabelDict"
    ],
    "autodisplay": false
},
{
    "id": 25,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_25,
    "inputs": [
        "callRange",
        "d3",
        "margin",
        "width"
    ],
    "outputs": [
        "getDate",
        "now",
        "until",
        "nowDate",
        "untilDate",
        "scaleX"
    ],
    "autodisplay": false
},
{
    "id": 26,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_26,
    "inputs": [],
    "outputs": [
        "margin"
    ],
    "autodisplay": false
},
{
    "id": 27,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_27,
    "inputs": [
        "Timeline",
        "timelineData",
        "scaleX"
    ],
    "outputs": [
        "timeline"
    ],
    "autodisplay": false
},
{
    "id": 28,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_28,
    "inputs": [
        "d3",
        "width",
        "dodge"
    ],
    "outputs": [
        "Timeline"
    ],
    "autodisplay": false
},
{
    "id": 29,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_29,
    "inputs": [
        "d3"
    ],
    "outputs": [
        "dodge"
    ],
    "autodisplay": false
},
{
    "id": 30,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_30,
    "inputs": [
        "Plot",
        "d3"
    ],
    "outputs": [
        "beeswarm"
    ],
    "autodisplay": false
},
{
    "id": 31,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_31,
    "inputs": [
        "filteredBinnedCalls",
        "display"
    ],
    "outputs": [
        "timelineData"
    ],
    "autodisplay": false
},
{
    "id": 32,
    "mode": "html",
    "pinned": false,
    "hidden": false,
    "body": cell_32,
    "inputs": [
        "html"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 33,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_33,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 34,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_34,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 35,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_35,
    "inputs": [
        "FileAttachment",
        "display"
    ],
    "outputs": [
        "adjacencyList"
    ],
    "autodisplay": false
},
{
    "id": 36,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_36,
    "inputs": [
        "FileAttachment",
        "display"
    ],
    "outputs": [
        "timeBarData"
    ],
    "autodisplay": false
},
{
    "id": 37,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_37,
    "inputs": [
        "FileAttachment",
        "display"
    ],
    "outputs": [
        "groupToChartIdsDict"
    ],
    "autodisplay": false
},
{
    "id": 38,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_38,
    "inputs": [
        "FileAttachment",
        "display"
    ],
    "outputs": [
        "phonesChartData"
    ],
    "autodisplay": false
},
{
    "id": 39,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_39,
    "inputs": [
        "FileAttachment",
        "display"
    ],
    "outputs": [
        "entityLabelToIdDict"
    ],
    "autodisplay": false
},
{
    "id": 40,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_40,
    "inputs": [
        "FileAttachment",
        "display"
    ],
    "outputs": [
        "phonesTimeLineData"
    ],
    "autodisplay": false
}
];
export default definitions;
