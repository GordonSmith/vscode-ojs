import * as vscode from "vscode";

const DOCTYPE_REGEX = /^\uFEFF?\s*<!doctype\s+html>/i; // allow optional BOM
const NOTEBOOK_TAG_REGEX = /<notebook\b[^>]*>/i;
const NOTEBOOK_JS = "// Generated by vscode-ojs:";

export function isNotebookKitType(notebookType: string): boolean {
    return notebookType === "notebook-kit-default" || notebookType === "notebook-kit-option";
}

export function isObservableHTMLNotebook(content: string): boolean {
    if (!DOCTYPE_REGEX.test(content.slice(0, 64))) {
        return false;
    }
    return NOTEBOOK_TAG_REGEX.test(content); // full scan for <notebook> tag (rare & short)
}

export function isObservableJSNotebook(content: string): boolean {
    return content.startsWith(NOTEBOOK_JS);
}

export function isObservableNotebook(content: string): boolean {
    return isObservableJSNotebook(content) || isObservableHTMLNotebook(content);
}

export function isObservableNotebookDocument(doc?: vscode.TextDocument): boolean {
    if (doc?.languageId === "html" && doc?.uri.scheme === "file") {
        const firstTwo: string[] = [];
        for (let line = 0; line < Math.min(2, doc.lineCount); ++line) {
            firstTwo.push(doc.lineAt(line).text);
        }
        return isObservableHTMLNotebook(firstTwo.join("\n"));
    } else if (doc?.languageId === "javascript" && doc?.uri.scheme === "file") {
        return isObservableJSNotebook(doc.lineAt(0).text);
    }
    return false;
}

export async function isObservableNotebookUri(uri: vscode.Uri): Promise<boolean> {
    if (uri.scheme !== "file") {
        return false;
    }
    if (!uri.fsPath.toLowerCase().endsWith(".html") && !uri.fsPath.toLowerCase().endsWith(".js")) {
        return false;
    }
    const doc = vscode.workspace.textDocuments.find(d => d.uri.toString() === uri.toString() && (d.languageId === "html" || d.languageId === "javascript"));
    if (doc) {
        return isObservableNotebookDocument(doc);
    }
    const bytes = await vscode.workspace.fs.readFile(uri);
    const slice = bytes.byteLength > 64 ? bytes.slice(0, 64) : bytes;
    const content = new TextDecoder("utf-8").decode(slice);
    return isObservableNotebook(content);
}

export class HTMLNotebookDetector implements vscode.FileDecorationProvider, vscode.Disposable {
    private notebookType: string;
    private readonly emitter = new vscode.EventEmitter<vscode.Uri | vscode.Uri[] | undefined>();
    readonly onDidChangeFileDecorations: vscode.Event<vscode.Uri | vscode.Uri[] | undefined> = this.emitter.event;
    private disposables: vscode.Disposable[] = [];

    constructor(notebookType: string) {
        this.notebookType = notebookType;
        this.disposables.push(
            vscode.workspace.onDidSaveTextDocument(doc => {
                this.invalidateAndFire(doc.uri);
                this.updateContextFromActiveEditor();
            }),
            vscode.workspace.onDidChangeTextDocument(e => {
                this.invalidateAndFire(e.document.uri);
                if (vscode.window.activeTextEditor?.document === e.document) { this.updateContextFromActiveEditor(); }
            }),
            vscode.workspace.onDidCreateFiles(e => {
                e.files.forEach(f => this.emitter.fire(e.files.map(f => f)));
            }),
            vscode.workspace.onDidDeleteFiles(e => {
                e.files.forEach(f => this.emitter.fire(e.files.map(f => f)));
            }),
            vscode.workspace.onDidRenameFiles(e => {
                this.emitter.fire(e.files.map(f => f.newUri));
            }),
            vscode.workspace.onDidOpenTextDocument(doc => {
                if (doc.languageId === "html" || doc.languageId === "javascript") {
                    this.updateContextFromDocument(doc);
                }
            }),
            vscode.window.onDidChangeActiveTextEditor(editor => {
                if (editor) {
                    this.updateContextFromDocument(editor.document);

                } else {
                    void this.setContext(false);

                }
            }),
            vscode.workspace.onDidOpenNotebookDocument(nb => {
                if (nb.notebookType === this.notebookType) {
                    void this.setContext(true);
                }
            }),
            vscode.window.onDidChangeActiveNotebookEditor(nbEditor => {
                if (nbEditor && nbEditor.notebook.notebookType === this.notebookType) {
                    void this.setContext(false);
                }
            })
        );
        this.updateContextFromActiveEditor();
    }

    async setContext(isObservableNotebook: boolean): Promise<void> {
        try {
            await vscode.commands.executeCommand("setContext", "observable-kit.isObservableNotebook", isObservableNotebook);
        } catch (error) {
            console.error("Failed to set context:", error);
        }
    }

    private updateContextFromActiveEditor(): void {
        void this.updateContextFromDocument(vscode.window.activeTextEditor?.document);
    }

    private updateContextFromDocument(doc?: vscode.TextDocument): void {
        void this.setContext(isObservableNotebookDocument(doc));
    }

    async provideFileDecoration(uri: vscode.Uri): Promise<vscode.FileDecoration | undefined> {
        if (await isObservableNotebookUri(uri)) {
            return {
                badge: "ⓝ",
                tooltip: "ObservableHQ Notebook"
            };
        }
        return undefined;
    }

    private invalidateAndFire(uri: vscode.Uri): void {
        this.maybeFire(uri);
    }

    private maybeFire(uri: vscode.Uri): void {
        if (uri.fsPath.toLowerCase().endsWith(".html") || uri.fsPath.toLowerCase().endsWith(".js")) {
            this.emitter.fire(uri);
        }
    }

    dispose(): void {
        this.disposables.forEach(d => d.dispose());
        this.emitter.dispose();
    }
}