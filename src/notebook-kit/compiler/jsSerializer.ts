import { type Notebook, type Cell } from "./util";
import { compileNotebook } from "./compiler";
import * as acorn from "acorn";
import type { Node, Program, FunctionDeclaration, BlockStatement, ReturnStatement, TaggedTemplateExpression, Identifier, TemplateLiteral } from "acorn";

export const DECL = `\
import { type Definition } from "@hpcc-js/observablehq-compiler/runtime";
export declare const definitions: Definition[];
`;

function compiledJs(funcs: string[], defs: string[]) {
    return `\
// Generated by vscode-ojs: Do not edit this file.

${funcs.join("\n\n")}

export const definitions = [
${defs.join(",\n")}
];
`;
}

const SUPPORTED_TAGS: ReadonlyArray<Cell["mode"]> = [
    "md",
    "js",
    "ojs",
    "html",
    "tex",
    "sql",
    "dot"
] as const;

export function notebook2js(notebook: Notebook): string {
    const compiled = compileNotebook(notebook, { includePinned: false });

    const funcs: string[] = [];
    const defs: string[] = [];
    for (let i = 0; i < compiled.length; ++i) {
        const def: any = {
            ...notebook.cells[i],
            ...compiled[i],
        };
        delete def.value;
        if (def.body) {
            const fnStr = typeof def.body === "function" ? def.body.toString() : String(def.body);
            funcs.push(fnStr);
        }
        def.body = `cell_${def.id}`;
        const defStr = JSON.stringify(def, null, 4);
        defs.push(defStr.replace(/"cell_(\d+)"/g, "cell_$1"));
    }
    return compiledJs(funcs, defs);
}

export async function js2notebook(content: string): Promise<Notebook> {
    let compiledArr: Array<{ id: number; body?: (...args: unknown[]) => unknown }> = [];
    try {
        const dataUrl = `data:text/javascript;base64,${Buffer.from(content, "utf-8").toString("base64")}`;
        const mod: unknown = await import(/* webpackIgnore: true */ dataUrl);
        const defs = (mod as { definitions?: unknown }).definitions;
        const isCompiledDef = (v: unknown): v is { id: number; body?: (...args: unknown[]) => unknown } =>
            typeof v === "object" && v !== null && typeof (v as any).id !== "undefined";
        if (Array.isArray(defs)) {
            compiledArr = defs.filter(isCompiledDef) as Array<{ id: number; body?: (...args: unknown[]) => unknown }>;
        }
    } catch (_err) {
        compiledArr = [];
    }

    type RecoveredCell = {
        id: number;
        value: string;
        mode: Cell["mode"];
        pinned?: boolean;
        hidden?: boolean;
        output?: string;
        database?: string;
        since?: Date | string | number;
    };

    const recovered: RecoveredCell[] = [];

    const innerFromFn = (fn: (...args: unknown[]) => unknown): { src: string; tagged?: { mode: Cell["mode"]; content: string } } => {
        const s = fn.toString();
        const header = "function __wrapper__(){";
        const open = s.indexOf("{");
        const close = s.lastIndexOf("}");
        if (open < 0 || close <= open) return { src: "" };
        const bodyOnly = s.slice(open + 1, close);
        const bodyWrapped = `${header}\n${bodyOnly}\n}`;
        const templateElementText = (elem: { value: { cooked?: string | null; raw: string } }): string => {
            const v = elem?.value as { cooked?: string | null; raw: string };
            return (v?.cooked ?? v.raw) as string;
        };
        const normalizeIndent = (text: string): string => {
            const lines = text.replace(/\r\n/g, "\n").split("\n");
            const indents = lines
                .filter(l => l.trim().length > 0)
                .map(l => (l.match(/^[ \t]*/)?.[0] ?? ""));
            if (indents.length === 0) return text;
            const lens = indents.map(s => s.length);
            const positives = lens.filter(n => n > 0);
            const minPos = positives.length > 0 ? Math.min(...positives) : Math.min(...lens);
            if (minPos <= 0) return text;
            return lines.map(l => {
                const m = l.match(/^[ \t]*/)?.[0] ?? "";
                const toRemove = Math.min(m.length, minPos);
                return l.slice(toRemove);
            }).join("\n");
        };
        const reconstructTaggedContent = (tpl: TemplateLiteral): string => {
            const elements = tpl.quasis ?? [];
            const exprs = tpl.expressions ?? [];
            let content = "";
            for (let i = 0; i < elements.length; i++) {
                content += templateElementText(elements[i] as any);
                if (i < exprs.length) {
                    const e = exprs[i] as Node & { start: number; end: number };
                    const exprText = bodyWrapped.slice(e.start as number, e.end as number);
                    content += "${" + exprText + "}";
                }
            }
            return content;
        };
        try {
            const ast = acorn.parse(bodyWrapped, { ecmaVersion: "latest", sourceType: "script" }) as unknown as Program;
            const program = ast as Program;
            const funcDecl = program.body && program.body[0] as FunctionDeclaration;
            if (!funcDecl || funcDecl.type !== "FunctionDeclaration") return { src: stripTopLevelReturn(bodyOnly).trim() };
            const block = funcDecl.body as BlockStatement;
            const statements = block?.body ?? [];
            const afterBrace = (block.start as number) + 1;
            const bodyOffset = bodyWrapped[afterBrace] === "\n" ? afterBrace + 1 : afterBrace;
            if (statements.length === 0) return { src: normalizeIndent(bodyOnly) };

            const first = statements[0];
            const last = statements[statements.length - 1];

            if (statements.length === 1 && first.type === "ReturnStatement") {
                let arg = (first as ReturnStatement).argument ?? null;
                if (!arg) return { src: "" };

                while (arg.type === "ParenthesizedExpression" && arg.expression) {
                    arg = arg.expression;
                }

                if (arg.type === "TaggedTemplateExpression" && (arg as TaggedTemplateExpression).tag?.type === "Identifier") {
                    const tagName = ((arg as TaggedTemplateExpression).tag as Identifier).name as Cell["mode"] | string;
                    const tpl = (arg as TaggedTemplateExpression).quasi as TemplateLiteral;
                    if (SUPPORTED_TAGS.includes(tagName as Cell["mode"])) {
                        const content = reconstructTaggedContent(tpl);
                        return { src: content, tagged: { mode: tagName as Cell["mode"], content } };
                    }
                }
                const start = Math.max(0, (arg.start as number) - bodyOffset);
                const end = Math.max(start, (arg.end as number) - bodyOffset);
                return { src: normalizeIndent(bodyOnly.slice(start, end)) };
            }

            let sliceStart = (first.start as number) - bodyOffset;
            let sliceEnd = (last.type === "ReturnStatement" ? (last.start as number) : (last.end as number)) - bodyOffset;
            sliceStart = Math.max(0, sliceStart);
            sliceEnd = Math.max(sliceStart, sliceEnd);
            return { src: normalizeIndent(bodyOnly.slice(sliceStart, sliceEnd)) };
        } catch {
            return { src: normalizeIndent(stripTopLevelReturn(bodyOnly)) };
        }
    };

    function stripTopLevelReturn(fnBody: string): string {
        const code = fnBody ?? "";
        if (!code.trim()) return code;
        const header = "function __wrapper__(){";
        const wrapped = `${header}\n${code}\n}`;
        let ast: Node | undefined;
        try {
            ast = acorn.parse(wrapped, {
                ecmaVersion: "latest",
                sourceType: "script",
                allowReturnOutsideFunction: false
            }) as unknown as Program;
        } catch {
            const trimmed = code.trim();
            const leadingReturn = /^return\s*\((.|\n|\r|\t)*\)\s*;?\s*$/m;
            if (leadingReturn.test(trimmed)) {
                return trimmed.replace(/^return\s*\(/, "").replace(/\)\s*;?\s*$/, "").trim();
            }
            const lastReturnIdx = trimmed.lastIndexOf("return ");
            if (lastReturnIdx >= 0) {
                return trimmed.slice(0, lastReturnIdx).trim();
            }
            return code;
        }
        const program = ast as Program;
        const funcDecl = program.body && program.body[0] as FunctionDeclaration;
        if (!funcDecl || funcDecl.type !== "FunctionDeclaration") return code;
        const block = funcDecl.body as BlockStatement;
        const statements = block && Array.isArray(block.body) ? block.body : [];
        const afterBrace = (block.start as number) + 1;
        const bodyOffset = wrapped[afterBrace] === "\n" ? afterBrace + 1 : afterBrace;
        if (statements.length === 0) {
            return code;
        }

        const first = statements[0];
        const last = statements[statements.length - 1];
        if (statements.length === 1 && first.type === "ReturnStatement") {
            const arg = (first as ReturnStatement).argument ?? null;
            if (!arg) return ""; // `return;` â†’ empty body
            const start = Math.max(0, (arg.start as number) - bodyOffset);
            const end = Math.max(start, (arg.end as number) - bodyOffset);
            return code.slice(start, end);
        }
        if (last.type === "ReturnStatement") {
            const keepStart = (first.start as number) - bodyOffset;
            const dropStart = (last.start as number) - bodyOffset;
            const kept = code.slice(keepStart, dropStart);
            return kept;
        }
        return code;
    }

    for (const def of compiledArr) {
        const id = Number(def.id);
        const bodyFn: unknown = def.body;
        if (typeof id !== "number" || !Number.isFinite(id)) continue;
        const mode: Cell["mode"] | undefined = (def as any).mode;
        if (typeof bodyFn === "function") {
            const { src, tagged } = innerFromFn(bodyFn as (...args: unknown[]) => unknown);
            if (tagged) {
                recovered.push({ id, value: tagged.content, mode: tagged.mode });
            } else {
                recovered.push({ id, value: src, mode: mode ?? "js" });
            }
            continue;
        }
        recovered.push({ id, value: "", mode: mode ?? "js" });
    }

    const cells: Cell[] = recovered.map(rc => {
        return {
            id: rc.id,
            value: rc.value,
            mode: rc.mode,
            pinned: rc.pinned ?? false,
            hidden: rc.hidden ?? false,
            output: rc.output,
            database: rc.database,
            since: typeof rc.since === "string" || typeof rc.since === "number" ? new Date(rc.since) : rc.since
        };
    });

    const notebook: Notebook = {
        title: "",
        theme: "air",
        readOnly: false,
        cells
    };

    return notebook;
}
