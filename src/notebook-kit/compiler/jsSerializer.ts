import { type Notebook, type Cell } from "./util";
import { compileKit } from "./compiler";
import * as acorn from "acorn";

export function notebook2js(notebook: Notebook): string {
    const compiled = compileKit(notebook);

    let compiledJs = "// Generated by vscode-ojs: Observable Notebook Kit compiled definitions\n";
    compiledJs += "\n";
    let exportJs = "const compiled = [\n";
    for (let i = 0; i < compiled.length; ++i) {
        const def: any = {
            ...notebook.cells[i],
            ...compiled[i],
        };
        delete def.value;
        if (def.body) {
            const fnStr = typeof def.body === "function" ? def.body.toString() : String(def.body);
            compiledJs += fnStr;
        }
        compiledJs += "\n";
        def.body = `cell_${def.id}`;
        const defStr = JSON.stringify(def, null, 4);
        exportJs += defStr
            .replace(/"cell_(\d+)"/g, "cell_$1")
            .replace(`\"${JSON.stringify(def.value)}\"`, JSON.stringify(def.value))
            ;
        exportJs += i < compiled.length - 1 ? ",\n" : "\n";
    }
    exportJs += "];\n";
    exportJs += "export default compiled;\n";
    compiledJs += exportJs;

    return compiledJs;
}

export async function js2notebook(content: string): Promise<Notebook> {

    // Attempt to dynamically import the ESM module from a data URL.
    // This preserves module semantics (e.g., named functions referenced by the compiled array).
    let compiledArr: Array<{ id: number; body?: (...args: unknown[]) => unknown }> = [];
    try {
        const dataUrl = `data:text/javascript;base64,${Buffer.from(content, "utf-8").toString("base64")}`;
        const mod: unknown = await import(/* webpackIgnore: true */ dataUrl);
        const maybeDefault = (mod as { default?: unknown }).default;
        const isCompiledDef = (v: unknown): v is { id: number; body?: (...args: unknown[]) => unknown } =>
            typeof v === "object" && v !== null && typeof (v as any).id !== "undefined";
        if (Array.isArray(maybeDefault)) {
            compiledArr = maybeDefault.filter(isCompiledDef) as Array<{ id: number; body?: (...args: unknown[]) => unknown }>;
        }
    } catch (_err) {
        // Fallback: tolerate legacy content by stripping export and evaluating in a sandboxed Function.
        try {
            const code = content.replace(/\n?export\s+default\s+compiled\s*;?\s*$/m, "");
            const compiledArrUnknown: unknown = new Function(`${code}; return typeof compiled !== "undefined" ? compiled : globalThis.compiled;`)();
            const isCompiledDef = (v: unknown): v is { id: number; body?: (...args: unknown[]) => unknown } =>
                typeof v === "object" && v !== null && typeof (v as any).id !== "undefined";
            compiledArr = Array.isArray(compiledArrUnknown)
                ? (compiledArrUnknown.filter(isCompiledDef) as Array<{ id: number; body?: (...args: unknown[]) => unknown }>)
                : [];
        } catch {
            compiledArr = [];
        }
    }

    type RecoveredCell = {
        id: number;
        value: string;
        mode: Cell["mode"];
        pinned?: boolean;
        hidden?: boolean;
        output?: string;
        database?: string;
        since?: Date | string | number;
    };

    const recovered: RecoveredCell[] = [];

    // Helper to extract the inner of a function body as text
    // 1) Extract the substring between the outermost curly braces
    // 2) Normalize indentation by removing the common leading spaces
    // 3) Remove any top-level `return` statements (both `return (expr)` and `return expr;`)
    const innerFromFn = (fn: (...args: unknown[]) => unknown): { src: string; mdContent?: string } => {
        const s = fn.toString();
        const header = "function __wrapper__(){";
        const wrapped = `${header}\n${s}\n}`; // intentionally wrap the whole function text as a statement
        // However, we only need the original function body; get it from toString via braces
        const open = s.indexOf("{");
        const close = s.lastIndexOf("}");
        if (open < 0 || close <= open) return { src: "" };
        const bodyOnly = s.slice(open + 1, close);

        // Parse the body (wrapped in a function so return is valid)
        const bodyWrapped = `${header}\n${bodyOnly}\n}`;
        type AnyNode = any;
        try {
            const ast = acorn.parse(bodyWrapped, { ecmaVersion: "latest", sourceType: "script" }) as unknown as AnyNode;
            const program = ast as AnyNode;
            const funcDecl = program.body && program.body[0];
            if (!funcDecl || funcDecl.type !== "FunctionDeclaration") return { src: stripTopLevelReturn(bodyOnly).trim() };
            const block: AnyNode = funcDecl.body;
            const statements: AnyNode[] = block?.body ?? [];
            const bodyOffset = header.length + 1; // +1 for \n
            if (statements.length === 0) return { src: bodyOnly.trim() };

            const first = statements[0];
            const last = statements[statements.length - 1];

            // Single return → extract argument source; detect md tagged template
            if (statements.length === 1 && first.type === "ReturnStatement") {
                const arg: AnyNode | null = first.argument ?? null;
                if (!arg) return { src: "" };
                // If tagged template md`...` with no expressions, this is a markdown cell body
                if (arg.type === "TaggedTemplateExpression" && arg.tag?.type === "Identifier") {
                    const tagName: string = arg.tag.name;
                    const tpl: AnyNode = arg.quasi;
                    const hasExpr = Array.isArray(tpl.expressions) && tpl.expressions.length > 0;
                    if (tagName === "md" && !hasExpr) {
                        // Join cooked quasis for readable content
                        const cooked = tpl.quasis.map((q: AnyNode) => q.value.cooked).join("");
                        return { src: cooked, mdContent: cooked };
                    }
                }
                const start = Math.max(0, (arg.start as number) - bodyOffset);
                const end = Math.max(start, (arg.end as number) - bodyOffset);
                return { src: bodyOnly.slice(start, end).trim() };
            }

            // Drop trailing return if present
            let sliceStart = (first.start as number) - bodyOffset;
            let sliceEnd = (last.type === "ReturnStatement" ? (last.start as number) : (last.end as number)) - bodyOffset;
            sliceStart = Math.max(0, sliceStart);
            sliceEnd = Math.max(sliceStart, sliceEnd);
            return { src: bodyOnly.slice(sliceStart, sliceEnd).trim() };
        } catch {
            // Fall back to previous heuristic
            return { src: stripTopLevelReturn(bodyOnly).trim() };
        }
    };

    // Remove top-level return statements from a function body.
    // Handles both:
    //  - return (extracted);
    //  - extracted;return {..., ...};
    function stripTopLevelReturn(fnBody: string): string {
        const code = fnBody ?? "";
        if (!code.trim()) return code;

        // Wrap the body in a function so that `return` is valid for parsing
        const header = "function __wrapper__(){";
        const wrapped = `${header}\n${code}\n}`;
        let ast: acorn.Node | undefined;
        try {
            ast = acorn.parse(wrapped, {
                ecmaVersion: "latest",
                sourceType: "script",
                allowReturnOutsideFunction: false
            }) as unknown as acorn.Node;
        } catch {
            // If parsing fails, fall back to simple heuristics
            // 1) leading `return ( ... );` → strip `return` and parens
            // 2) trailing `return ...;` → remove the trailing return
            const trimmed = code.trim();
            const leadingReturn = /^return\s*\((.|\n|\r|\t)*\)\s*;?\s*$/m;
            if (leadingReturn.test(trimmed)) {
                return trimmed.replace(/^return\s*\(/, "").replace(/\)\s*;?\s*$/, "").trim();
            }
            const lastReturnIdx = trimmed.lastIndexOf("return ");
            if (lastReturnIdx >= 0) {
                return trimmed.slice(0, lastReturnIdx).trim();
            }
            return code;
        }

        // The AST is a Program with a single FunctionDeclaration named __wrapper__
        type AnyNode = any; // local helper to avoid strict Node typing for positional properties
        const program = ast as AnyNode;
        const funcDecl = program.body && program.body[0];
        if (!funcDecl || funcDecl.type !== "FunctionDeclaration") return code;
        const block: AnyNode = funcDecl.body; // BlockStatement
        const statements: AnyNode[] = block && Array.isArray(block.body) ? block.body : [];

        // Compute offsets so we can slice from original `code`
        // In wrapped source, the function body starts after `${header}\n`
        const bodyOffset = header.length + 1; // +1 for the inserted \n
        if (statements.length === 0) {
            return code.trim();
        }

        const first = statements[0];
        const last = statements[statements.length - 1];

        // Case A: entire body is a single ReturnStatement
        if (statements.length === 1 && first.type === "ReturnStatement") {
            const arg: AnyNode | null = first.argument ?? null;
            if (!arg) return ""; // `return;` → empty body
            const start = Math.max(0, (arg.start as number) - bodyOffset);
            const end = Math.max(start, (arg.end as number) - bodyOffset);
            return code.slice(start, end).trim();
        }

        // Case B: trailing ReturnStatement — drop it, keep preceding statements
        if (last.type === "ReturnStatement") {
            const keepStart = (first.start as number) - bodyOffset;
            const dropStart = (last.start as number) - bodyOffset;
            const kept = code.slice(keepStart, dropStart).trim();
            return kept;
        }

        // Otherwise, keep the body as-is
        return code.trim();
    }

    // Attempt to preserve the order defined in the compiled array
    for (const def of compiledArr as any[]) {
        const id = Number(def.id);
        const bodyFn: unknown = def.body;
        if (typeof id !== "number" || !Number.isFinite(id)) continue;

        // Prefer explicit value/mode if present in compiled definition
        const hasValue = typeof def.value === "string";
        const mode: Cell["mode"] | undefined = def.mode;
        if (hasValue) {
            recovered.push({
                id,
                value: def.value as string,
                mode: mode ?? "js",
                pinned: Boolean(def.pinned),
                hidden: Boolean(def.hidden),
                output: def.output,
                database: def.database,
                since: def.since
            });
            continue;
        }

        if (typeof bodyFn === "function") {
            const { src, mdContent } = innerFromFn(bodyFn as (...args: unknown[]) => unknown);
            if (mdContent && !mode) {
                recovered.push({ id, value: mdContent, mode: "md" });
            } else {
                recovered.push({ id, value: src, mode: mode ?? "js" });
            }
            continue;
        }

        // Last resort: empty js cell
        recovered.push({ id, value: "", mode: mode ?? "js" });
    }

    // Build VS Code NotebookData
    const cells: Cell[] = recovered.map(rc => {
        return {
            id: rc.id,
            value: rc.value,
            mode: rc.mode,
            pinned: rc.pinned ?? false,
            hidden: rc.hidden ?? false,
            output: rc.output,
            database: rc.database,
            since: typeof rc.since === "string" || typeof rc.since === "number" ? new Date(rc.since) : rc.since
        };
    });

    const notebook: Notebook = {
        title: "",
        theme: "air",
        readOnly: false,
        cells
    };

    return notebook;
}
